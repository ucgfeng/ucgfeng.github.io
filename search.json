[{"title":"Arch Linux 基础软件安装与KDE 桌面美化","url":"/2023/03/13/ArchLinux%E5%9F%BA%E7%A1%80%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%B8%8EKDE%E6%A1%8C%E9%9D%A2%E7%BE%8E%E5%8C%96/","content":"升级所有包并安装浏览器sudo pacman -Syyu# 安装KDEsudo pacman -S plasma-meta konsole dolphin# 启动登录窗口sudo systemctl enable --now sddmsudo pacman -S firefox # 安装浏览器\n\n安装oh-my-zshsudo pacman -S curl gitsudo pacman -S zsh zsh-autosuggestions zsh-syntax-highlighting zsh-completionssh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\n安装字体sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei wqy-microhei# 安装几个开源中文字体。sudo pacman -S noto-fonts noto-fonts-cjk noto-fonts-emoji noto-fonts-extra # 安装谷歌开源字体及表情\n安装基础软件sudo pacman -S ntfs-3g # 使系统可以识别 NTFS 格式的硬盘sudo pacman -S ark unrar # 压缩软件。在 dolphin 中可用右键解压压缩包sudo pacman -S packagekit-qt5 packagekit appstream-qt appstream # Discover（软件中心）sudo pacman -S gwenview # 图片查看器\n\n安装yay工具，用于安装aur中的包sudo pacman -S archlinuxcn-keyring # cn 源中的签名（archlinuxcn-keyring 在 archlinuxcn）sudo pacman -S yay # yay 命令可以让用户安装 AUR 中的软件（yay 在 archlinuxcn）\n\nSDDM修改主题sudo vim /usr/lib/sddm/sddm.conf.d/default.confcurrent = breeze\n\n安装输入法sudo pacman -S fcitx5-im # 输入法基础包组sudo pacman -S fcitx5-chinese-addons # 官方中文输入引擎sudo pacman -S fcitx5-material-color # 输入法主题#sudo pacman -S fcitx5-rime  rime-cloverpinyin  # rime输入法组件\n\n编辑&#x2F;etc&#x2F;，使输入法能够被识别sudo vim /etc/environment\nGTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus\n\nsudo pacman -S latte-dock # 安装dock工具sudo pacman -S kvantum # 建议安装，大部分主题需要利用它进一步优化QT界面\n\n图标： https://github.com/yeyushengfan258/Reversal-icon-themeROUNDED主题：https://store.kde.org/p/1352754/ROUNDED配套的Latte主题：https://www.pling.com/p/1571402壁纸：https://wallpaperscraft.com/catalog/anime/1920x1080透明标题栏：https://store.kde.org/p/1294013/\n","categories":["ArchLinux"],"tags":["Arch KDE"]},{"title":"Arch Linux 安装","url":"/2023/03/12/ArchLinux%E5%AE%89%E8%A3%85/","content":"验证引导模式ls /sys/firmware/efi/efivars# 或efivar -l\n命令结果显示了目录且没有报告错误，则系统以 UEFI 模式引导。如果目录不存在，则系统可能以 BIOS 模式 (或 CSM 模式) 引导。如果系统未以您想要的模式引导启动，请参考您的主板说明书。\nvmware记得开efi\n无线网络连接iwctl                       #执行iwctl命令，进入交互式命令行device list                 #列出设备名，比如无线网卡看到叫 wlan0station wlan0 scan          #用wlan0网卡扫描网络station wlan0 get-networks  #列出网络station wlan0 connect 无线网名字    #连接网络名字 输入密码exit或者quit                #成功后退出\nping 一下某个网站 看看是否连接成功\n换源#设置中科大源vim /etc/pacman.d/mirrorlistServer = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$archpacman -Syy\n\n更新系统时间timedatectl set-ntp true \n\n硬盘分区fdisk -l  #查看分区fdisk /dev/sda #分区，也可以用cfdisk# 编号自定义# 大小 +512MB +4Gp #打印分区信息w #保存 \n\n格式化分区mkfs.vfat /dev/sda1 mkswap /dev/sda2mkfs.ext4 /dev/sda3swapon /dev/sda2\n\n挂载分区mount /dev/sda3 /mnt mkdir /mnt/bootmount /dev/sda1 /mnt/boot\n\n安装秘钥pacman -S archlinux-keyring\n安装基础包pacstrap /mnt base base-devel linux linux-firmware dhcpcdpacstrap /mnt linux linux-firmware linux-headers base base-devel vim bash-completion\n\n配置fstabgenfstab -U /mnt &gt;&gt; /mnt/etc/fstabcat /mnt/etc/fstab\n\n切根arch-chroot /mnt\n\n设置时区ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtimehwclock --systohc #同步时间\n\n安装软件pacman -S vim dialog wpa_supplicant ntfs-3g networkmanager netctl\n\n设置语言vim /etc/locale.gen# 把想要设置的语言注释放开en_US.UTF-8 UTF-8zh_CN.UTF-8 UTF-8locale-gen echo LANG=en_US.UTF-8 &gt; /etc/locale.conf\n\n设置主机名字echo arch &gt; /etc/hostname\n\n配置hosts127.0.0.1 localhost::1 localhost127.0.1.1 主机名字.localdomain [主机名字]\n\n设置root 密码passwd \n安装软件pacman -S intel-ucodepacman -S os-prober pacman -S grub efibootmgr\n\ngrub# 虚拟机如果没开efi用这个，否则可以和物理机一致grub-install --target=i386-pc /dev/sda物理机  grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUBgrub-mkconfig -o /boot/grub/grub.cfg#物理机如果是双系统，安装完grub后没发现另一个系统vim /etc/defalut/grub#把GRUB_DISABLE_OS_PROBER=false的注释去掉grub-mkconfig -o /boot/grub/grub.cfgcat /boot/grub/grub.cfg\n\n安装sshsudo pacman -S opensshvim /etc/ssh/sshd_config#添加PermitRootLogin yes#保存退出#开启ssh服务systemctl enable sshd #下次开机开启systemctl start sshd #现在开启\n\n退出并取消挂载重新启动exitumount -R /mnt #取消挂载reboot #物理机拔u盘\n\n\n驱动和桌面环境#安装显卡 驱动和openGLsudo pacman -S nvidia nvidia-utils#桌面环境sudo pacman -S xorg plasma kde-applications sddm networkmanager network-manager-appletsudo systemctl enable sddmsudo systemctl disable netctlsudo systemctl enable NetworkManager#安装软件pacman -S firefox ark gwenview git wget packagekit-qt5 packagekit docker appstream-qt appstream man neofetch net-tools\n\n\n\n","categories":["ArchLinux"],"tags":["Arch install"]},{"title":"ArchLinux常用软件","url":"/2023/04/02/ArchLinux%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/","content":"\n终端编辑器: vim\naur包管理器: yay\n图形界面编辑器: gedit\n网络连接: iw, wpa_ supplicant和dhcpcd\n电池优化: tlp\n声音管理: alsa-utils, pulseaudio, pavucontr\n图形界面服务: xorg、 xinit\n通知：dunst\n剪贴板：copyq\n搜索栏:dmenu(能快速搜索打开某个应用，一步到位，配合i3wm)\n顶部栏: polybar\ni3壁纸管理: feh (装gnome和kde这种有自带的工具，不需要它这个)\nxorg渲染工具: picom (gnome和kde这种也不需要它)\n终端模拟器: gnome-terminal (gnome桌面默认终端模拟器)、alacritty (使用GPU加速，可定制)\nshell: fish (比默认的bash强大好用，但是和bash脚本不兼容)、zsh (比bash 好用，不如fish，需要折腾配置后才能达到和fish类似的效果，好处是兼容bash脚本)\n终端下的文件浏览器: ranger (非常强大)\n图片查看和编辑:gthumb.\n类似Ps的图片编辑器:gimp\nSVG编辑器: inkscape\n视频剪辑:kdenlive(类似Pr)， openshot(稍微简单点)\n录屏和直播软件: obs\n摄像头:摄像头驱动自带fplay和ffmpeg图形界面操作的有cheese\n树状列出各级目录: tree\nlinux远程操作: ssh\n输入法框架: fcitx或者ibus (gnome自带ibus)\n输入法: sunpinyin\nMarkdown编辑器: typora\nC语言编译器: gcc\n项目构建和管理: make , cmake, maven, npm\nC++编译器: g++\n调试器: gdb\n虚拟机: virtualbox\n百度网盘: baidunetdisk\n数据库: mariadb (mysql的开源版)\n浏览器: chromium (谷歌浏览器开源版)- 键盘操作chromium: vimium插件\n视频播放器: vlc\n项目管理和版本控制器: git. subversion\n制作windows启动盘: woeusb\n发现电脑内的其他系统: os-prober\n访问远程Windows桌 面: rdesktop\ndos模拟器: dosemu\n原型工具: pencil\n路由跟踪: traceroute\nnslookup: arch在 dnsutils包里面，其他发行版应该在bind-utils里。\n网络工具: ifconfig、 route在net-tools中， nslookup,dig在dnsutils中，ftp,telnet等 在inetutils中,ip命令在iproute2中。\n手机投屏到电脑: scrcpy .\n电脑投屏到手机: vnc系列或者rdp系列，vnc服务端(电脑)x11vnc;客户端(手机)可以去应用商店搜vnc，vncviewer，”bVNC Free”。\n处理deb包: debtap\n终端256色打印图片: catimg\n图片转文本: chafa (有彩色，比catimg更清晰)\n图片转ASCII: jp2a\n下载器: uget， aria2\n安装terminfo: tic\n\n","categories":["ArchLinux"],"tags":["ArchLinux"]},{"title":"ArchLinux配置及问题","url":"/2023/03/20/ArchLinux%E9%85%8D%E7%BD%AE%E5%8F%8A%E9%97%AE%E9%A2%98/","content":"启动后的配置工作# 添加archlinuxcn源vim /etc/pacman.conf #文件末尾添加两行：[archlinuxcn]Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch# 更新系统源pacman -Sy# 安装archlinuxcn秘钥pacman -S archlinuxcn-keryingpacman -S bash-completion #bash下命令自动补全#添加用户useradd -m -G wheel username#设置密码passwd username#配置sudopacman -S sudo# 设置软链接，把vim链接到viln -s /usr/bin/vim /usr/bin/vivisudo:/wheel#取消注释\n\n安装archlinuxcn-keyring报错pacman -S archlinuxcn-keyring如果报错，#用root用户执行以下命令rm -rf /etc/pacman.d/gnupgpacman-key --initpacman-key --populate archlinuxpacman-key --populate archlinuxcn\n文件相关的颜色配置sudo vim /etc/skel/.bashrc~/.bashrc# 编辑器设置为vimexport EDITOR=vim# 别名的定义alias pm=&#x27;pacman&#x27;alias ra=&#x27;ranger&#x27;alias c=&#x27;clear&#x27;alias ll=&#x27;ls -l --color=auto&#x27;alias ls=&#x27;ls --color=auto&#x27;alias la=&#x27;ls -a --color=auto&#x27;alias gs=&#x27;git status&#x27;alias gaa=&#x27;git add -A&#x27;alias gcm=&#x27;git commit -m&#x27;alias gll=&#x27;git pull&#x27;alias gsh=&#x27;git push&#x27;alias gla=&#x27;git log --graph --pretty=format:&quot;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&quot; --abbrev-commit --date=relative --all&#x27;alias ls=&#x27;ls --color=auto&#x27;alias grep=&#x27;grep --color=auto&#x27;alias egrep=&#x27;egrep --color=auto&#x27;alias fgrep=&#x27;fgrep --color=auto&#x27;[ ! -e ~/.dircolors ] &amp;&amp; eval $(dircolors -p &gt; ~/.dircolors)[ -e /bin/dircolors ] &amp;&amp; eval $(dircolors -b ~/.dircolors)\n\n安装xfce4桌面和lightdmsudo pacman -S xorg lightdm lightgdm-gtk-greeter lightdm-gtk-greeter-settings xfce4 xfce4-goodies\n\n检测不到另一个系统# 先确认是否安装os-prober# 如果没有安装，先进行安装sudo pacman -S os-prober# 编辑grub配置文件sudo vim /etc/default/grub# 把下面这行的注释去掉下面这行注释，如果没有就手动添加GRUB_DISABLE_OS_PROBER=false# 重新生成grub配置文件sudo grub-mkconfig -o /boot/grub/grub.cfg\n\n双系统时间不同步在linux系统中执行以下命令timedatectl set-local-rtc true\n\n安装fcitx5输入法sudo pacman -S fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-qt \n\n编辑 /etc/environment 并添加以下几行，然后重新登录:\nsudo vim /etc/environmentGTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitxGLFW_IM_MODULE=ibus\n\n\n\narchlinux安装fcitx5 之后 浏览器不能输入中文重新安装fcitx5-qt，把&#x2F;etc&#x2F;locale.conf里面改为LANG&#x3D;zh_CN.UTF-8\n字体渲染sudo vim /etc/profile.d/freetype2.sh最后一行注释取消export FREETYPE_PROPERTIES=&quot;truetype:interpreter-version=40&quot;\n\nparu 反转查询结果sudo vim /etc/paru.conf取消下面注释BottomUp\n\n禁用Nvidia开源驱动sudo vim /etc/default/grub#在下面这行GRUB_CMDLINE_LINUX_DEFAULT添加  module_blacklist=nouveau\n生成配置文件，每次修改&#x2F;etc&#x2F;default&#x2F;grub文件后都要执行一下以下命令\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n内核和驱动的相关问题：sudo pacman -S nvidiamhwd-kernel -lsudo mhwd-kernel -i linuxXXX rmc#其中，linuxXXX是指列出的最新版本内核，rmc是删除旧内核rebootsudo pacman -S nvidia linuxXXX-nvidia-XXX\n\nArch + DDE不能连接wifi#wifi连不上是因为NetWorkManager这个组件在连接wifi的时候会生成随机的mac地址，而dde里面和它配套的com.deepin.network这个包魔改过，不支持这个特性。禁用随机mac，sudo vim /etc/NetworkManager/MetworkManager.conf#新添加2行内容[device]wifi.scan-rand-mac-address=no#保存退出，重启下NetworkManager即可sudo systemctl restart NetworkManager\nGNOME桌面sudo pacman -S gnome tilix  gnome-tweaks#插件里面把一个user Themes的插件打开 可以修改默认shell主题#tweaks 里面窗口标题栏可以把最大化最小化调出来paru -S yaru-gnome-shell-theme yaru-icon-theme yaru-sound-themesudo pacman -S gnome-browerser-connector chrome-gnome-shell #插件#Applndicator and KStatusNotifierItem Support #托盘图标#dash to dock 桌面上显示dock#no overview at start-up 开机显示桌面#rounded window corners 圆角#blur my shell 切换桌面时壁纸#录制视频需安装 gst-plugin-pipewire#插件#dash to dock#blur my shell 工作区半透明#arcmenu 左边菜单集成#vitals 电脑各项信息#just perfection 减掉不必要的#app indicator 托盘图标#clipboard 剪切板记录#compiz 最小化最大化魔灯效果#cosmic 比dash to dock 流畅#input method panel fcitx的美化扩展#net speed\n\n字体相关sudo cp -r Fonts /usr/share/fonts/windowssudo fc-cache -f\n\ndwm状态栏设置while truedo    LI=`xbacklight | cut -d. -f1`    BA=`acpi | cut -d, -f2 | cut -d% -f1 | cut -d&quot; &quot; -f2`    SO=`amixer get Master | sed -n &#x27;$p&#x27; | cut -d] -f1 | cut -d[ -f2 | cut -d% -f1`    DA=`date | cut -d&quot; &quot; -f 1,2,3,5,6`    xsetroot -name &quot;Vol.$&#123;SO&#125;|Bal.$&#123;LI&#125;|Bat.$&#123;BA&#125;|$&#123;DA&#125;&quot;    sleep 1sdone &amp;\n\nFailed to start Load Kernel Modulesfile boot/vmlinuz-linux #查看当前引导所引导的内核版本#升级内核grub-install -target=x86_64-efi --efi-directory=/boot --bootloader-id=GRUBgrub-mkconfig -o /boot/grub/grub.cfg\n\n双系统删除arch引导这里以win11+arch为例\nEFI文件夹里面的grub删除外面的grub不能删除，System Volume Information不能删除其他的都删除\n更换鼠标主题#安装主题paru breeze-purple-cursor-theme# 查找安装的主题find /usr/share/icons ~/.local/share/icons ~/.icons -type d -name &quot;cursors&quot;# 配置主题sudo vim /usr/share/icons/default/index.theme[icon theme]Inherits=Breeze_Purple\n\n\n\n安装alacritty主题#安装alacritty-colorschemeparu alacritty-colorscheme#克隆主题（下面是github上的两个主题库）git clone https://github.com/aaron-williamson/base16-alacritty.gitcp base16-alacritty/colors/* ~/.config/alacritty/colors/git clone https://github.com/eendroroy/alacritty-theme.gitcp alacritty-theme/themes/* ~/.config/alacritty/colors/#使用主题#$HOME/.config/alacritty/colors/ 目录下的都是主题文件，任选一个自己喜欢的alacritty-colorscheme apply xxx#查看当前使用的主题alacritty-colorscheme status\n\n\n\n蓝牙问题#先把用户追加到组 lp中sudo usermod -a -G lp username\n\nbluetoothd[4365]: profiles/audio/vcp.c:vcp_init() D-Bus experimental not enabledbluetoothd[4365]: src/plugin.c:plugin_init() Failed to init vcp pluginbluetoothd[4365]: profiles/audio/mcp.c:mcp_init() D-Bus experimental not enabledbluetoothd[4365]: src/plugin.c:plugin_init() Failed to init mcp pluginbluetoothd[4365]: profiles/audio/bap.c:bap_init() D-Bus experimental not enabledbluetoothd[4365]: src/plugin.c:plugin_init() Failed to init bap plugin\n\n# 解决上面的问题sudo vim /etc/bluetooth/main.conf Experimental=true  # systemctl 不能启动 sudo modprobe -r btusb &amp;&amp; sudo modprobe btusb\n\n#用到的命令lspci -klsmod | grep btusbrfkill listsudo dmesg | grep Blue\n\nLinux安装idea下载对应版本解压到对应文件夹这里以/opt/idea为例配置idea.sh 在任何路径下启动vim .bashrc在最后添加以下两行export IDEA_HOME=/opt/ideaexport PATH=:$&#123;PATH&#125;:$&#123;IDEA_HOME&#125;/bin 配置完成后，想直接使用source ~/.bashrc\n\n","categories":["ArchLinux"],"tags":["Arch config"]},{"title":"Linux命令","url":"/2023/03/23/Linux%E5%91%BD%E4%BB%A4/","content":"快捷键ctrl+a  光标回到行首ctrl+e  光标回到行尾ctrl+f  光标向右移动一个字符 forwardsctrl+b  光标向左移动一个字符 behindctrl+u  删除光标处到行首的所有字符ctrl+k  删除光标处到行尾的所有字符ctrl+w  删除光标前的一个单词wordctrl+h  删除光标前的一个字符，相当于退格键esc+b   移动到当前单词的开头esc+f   移动到当前单词的结尾esc+t   当前单词向前移动\n终端下md文档插入图片![](./xxx.png)\n\ndu-a, --all                              显示目录中个别文件的大小。-B, --block-size=大小                  使用指定字节数的块-b, --bytes                            显示目录或文件大小时，以byte为单位。-c, --total                            除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D, --dereference-args                 显示指定符号链接的源文件大小。-H, --si                               与-h参数相同，但是K，M，G是以1000为换算单位。-h, --human-readable                   以K，M，G为单位，提高信息的可读性。-k, --kilobytes                        以KB(1024bytes)为单位输出。-l, --count-links                      重复计算硬件链接的文件。-m, --megabytes                        以MB为单位输出。-L&lt;符号链接&gt;, --dereference&lt;符号链接&gt;  显示选项中所指定符号链接的源文件大小。-P, --no-dereference                   不跟随任何符号链接(默认)-0, --null                             将每个空行视作0 字节而非换行符-S, --separate-dirs                    显示个别目录的大小时，并不含其子目录的大小。-s, --summarize                        仅显示总计，只列出最后加总的值。-x, --one-file-xystem                  以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;, --exclude-from=&lt;文件&gt;        在&lt;文件&gt;指定目录或文件。--apparent-size                        显示表面用量，而并非是磁盘用量；虽然表面用量通常会小一些，但有时它会因为稀疏文件间的&quot;洞&quot;、内部碎片、非直接引用的块等原因而变大。--files0-from=F                        计算文件F中以NUL结尾的文件名对应占用的磁盘空间如果F的值是&quot;-&quot;，则从标准输入读入文件名--exclude=&lt;目录或文件&gt;                 略过指定的目录或文件。--max-depth=N                          显示目录总计(与--all 一起使用计算文件)当N为指定数值时计算深度为N，等于0时等同--summarize--si                                   类似-h，但在计算时使用1000 为基底而非1024--time                                 显示目录或该目录子目录下所有文件的最后修改时间--time=WORD                            显示WORD时间，而非修改时间：atime，access，use，ctime 或status--time-style=样式                      按照指定样式显示时间(样式解释规则同&quot;date&quot;命令)：full-iso，long-iso，iso，+FORMAT--help                                 显示此帮助信息并退出--version                              显示版本信息并退出\n\n# 查询该目录下所有资源的大小，包括压缩包的大小du -ah --max-depth=1\n\n\n\nfindfind 路径 [-type f] -name &quot;*.txt&quot;find 路径 [-type f] -name &quot;*.txt&quot; -o -name &quot;*.log&quot;\n\ngrep\n: 表示当前目录所有文件，也可以是某个文件名-r 是递归查找-n 是显示行号-R 查找所有文件包含子目录-i 忽略大小写grep &quot;相关内容&quot; 文件名ps -ef | grep &quot;nginx&quot;ls | grep -E &quot;txt|log&quot; #多个条件grep -rn &quot;xxx&quot; ~/workspace # grep 的orgrep &#x27;pattern1\\|pattern2&#x27; filenamegrep -E &#x27;pattern1|pattern2&#x27; filenameegrep &#x27;pattern1|pattern2&#x27; filename# grep 的notgrep -v &#x27;pattern&#x27; filename\n\nhelp-d 输出每个命令的简短描述-m 以类似man手册的格式描述命令-s 只显示命令使用格式--help选项绝大多数命令都可以使用--help选项来查看帮助ls --help 输出的帮助信息基本上是man命令的信息简要版\n\nmanman命令是最常见的帮助命令，也是Linux最主要的帮助命令，基本信息如下：man [选项] [章节] 命令man命令交互快捷键上：向上移动一行下：向下移动一行PgUP：向上翻一页PgDn：向下翻一页g：移动到第一页G：移动到最后一页q：退出/字符串：从当前向下搜索字符串?字符串：从当前向上搜索字符串n：当搜索字符串时，可以用n键找到下一个匹配N：同n,向上匹配\n\nnohup 命令nohup 英文全称 no hang up（不挂起），用于在系统后台不挂断地运行命令，退出终端不会影响程序的运行。\nnohup 命令，在默认情况下（非重定向时），会输出一个名叫 nohup.out 的文件到当前目录下，如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME&#x2F;nohup.out 文件中。\nnohup /root/runoob.sh &gt; runoob.log 2&gt;&amp;1 &amp;## 2&gt;&amp;1放在文件后面，不然启动的时候会报 nohup: redirecting stderr to stdout\n\n2&gt;&amp;1 解释：将标准错误 2 重定向到标准输出 &amp;1 ，标准输出 &amp;1 再被重定向输入到 runoob.log 文件中。\n\n0 – stdin (standard input，标准输入)\n1 – stdout (standard output，标准输出)\n2 – stderr (standard error，标准错误输出)\n\nssss -tunlp\n\ntail参数：\n\n-f 循环读取\n-q 不显示处理信息\n-v 显示详细的处理信息\n-c&lt;数目&gt; 显示的字节数\n-n&lt;行数&gt; 显示文件的尾部 n 行内容\n–pid&#x3D;PID 与-f合用,表示在进程ID,PID死掉之后结束\n-q, –quiet, –silent 从不输出给出文件名的首部\n-s, –sleep-interval&#x3D;S 与-f合用,表示在每次反复的间隔休眠S秒\n\n动态查看文件后30 行\ntail notes.log         # 默认显示最后 10 行tail -n 30 -f xxx\n\nxargsfind / -type f -name &quot;*.txt&quot; | xargs grep &quot;apple&quot;\n\n查看当前终端使用的哪种shellecho $0\t/bin/bashps -p $$    PID TTY          TIME CMD   2301 pts/0    00:00:02 bash\n\n查看linux版本cat /etc/os-releasecat /proc/version\n\n查看内存和文件系统df -T\n\n用户追加到组usermod -a -G group1,group2 username\n\n","categories":["linux"],"tags":["linux"]},{"title":"archLinux博客搭建","url":"/2022/12/19/archLinux%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"安装工具1.nodejs的安装2.npm的安装\nsudo pacman -S nodejs npm node -v #查看版本，如果出现版本就说明安装成功npm -v\n\n利用npm安装cnmpsudo npm install -g cnpm --registry=https://registry.npm.taobao.orgsudo cnpm install -g hexo-clihexo -v\n\n初始化博客#创建一个空文件夹mkdir blog#在搭建的过程中如果出现了错误，把blog删除，重新来cd blogsudo hexo init#出现start blogging with Hexo! 代表初始化仓库成功ls -l #查看生成的内容#生成静态文件sudo hexo g\n\n启动博客hexo s#出现https://localhost:4000 启动成功#浏览器访问https://localhost:4000可以进行查看\n\n部署到远端cnpm install --save hexo-deployer-gitvim _config.ymldeploy:  type: git  repo: 仓库地址用ssh  branch: main#生成公钥私钥,添加公钥到githubssh-keygen -t rsassh-agent -sssh-add ~/.ssh/id_rsassh -T git@github.com #测试连接hexo d \n\n\n博客中用到的命令#Create a new posthexo new name#Clean cachehexo clean#Gdnerate static fileshexo g#Run serverhexo s #Deploy to remote siteshexo d \n\n\n","categories":["blog"],"tags":["ArchLinux","blog"]},{"title":"arch微信安装","url":"/2023/02/21/arch%E5%BE%AE%E4%BF%A1%E5%AE%89%E8%A3%85/","content":"paru -S deepin-wine5 com.qq.weixin.deepin sudo vim /opt/apps/com.qq.weixin.deepin/files/run.sh# 手动把     export APPRUN_CMD=&quot;deepin-wine6-stable&quot;#改成     export APPRUN_CMD=&quot;deepin-wine5&quot;#或 sed -i.bak &#x27;22s/deepin-wine6-stable/deepin-wine5/g&#x27; /opt/apps/com.qq.weixin.work.deepin/files/run.sh启动命令 /opt/apps/com.qq.weixin.deepin/files/run.sh\n\n企业微信的安装paru -S wineparu -S com.qq.weixin.work.deepin# 修改启动命令sed -i.bak &#x27;16s/deepin-wine6-stable/wine/g&#x27; /opt/apps/com.qq.weixin.work.deepin/files/run.sh\n","categories":["ArchLinux"],"tags":["arch wechat"]},{"title":"docker","url":"/2023/05/19/docker/","content":"docker 介绍Docker最初是DotCloud公司在法国期间发起的一个公司内部项目，后来以Apache2.0授权协议开源，代码在Github_上维护。\nDocker是基于Google公司推出的Golang语言开发而来，基于Linpux内核的Cgroups、 NameSpace, 以及Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。\n由于隔离的进程独立于宿主机和其他隔离的进程，也被称之为容器。\n最初的Docker是基于LXC的，后来去除L XC转而使用自行开发的L ibcontainer。Docker被定义为开源的容器引擎，可以方便的对容器进行管理。例如对镜像打包封装，引入Docker Registry对镜像统一管理。\n利用Docker可以实现开发，测试，生产环境的部署一致性， 极大的减少运维成本。\n容器和虚拟机的差异传统虚拟机技术虚拟机是虚拟出一套硬件，在其上面运行一个完整的操作系统，例如我们使用的KVM,指定镜像，然后安装系统，最终可以使用，在该系统上再运行所需的应用程序。KVM创建虚拟机时，指定较少的CPU,内存，硬盘等资源，虚拟机性能较低。\n容器技术容器内的应用程序直接运行在宿主机的内核 上，窗口内没有自己的内核 ，也没有对硬件进行虚拟，因此容器比起虚拟机更为轻便\n容器对比KVM的好处\n窗口能够提供宿主机的性能，而KVM虚拟机是分配宿主机硬件资源，性能较弱\n同样配置的宿主机，最多可以启动10个虚拟机的话，可以启动100+的容器数量\n启动一个KVM虚拟机，得有一个完整的开机流程，花费时间较长，而启动一个窗口只需要一条命令\nKVM需要硬件CPU的虚拟化支持，而窗口不需要\n\n为什么选择docker\ndocker更高效的利用系统资源\n更快的启动时间\n一致性的环境\n持续交付和部署\n更轻松的迁移\n利用docker的镜像，部署迁移项目，还可以跨系统平台\n\ndocker能做什么\n可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署\n可以将镜像(image)启动成容器(container)，并且提供多容器的生命周期进行管理(启，停，删)\ncontainer容器之间相互隔离，且每个窗口可以设置资源限额\n提供轻量级虚拟化功能，容器就是宿主机中一个个的虚拟的空间，彼此相互隔离，完全独立\n\ndocker安装部署docker最核心的组件\nimage镜像，构建容器(我们将应用程序运行所需的环境，打包为镜像文件)\nContainer,容器(你的应用程序，就跑在容器中)\n镜像仓库(dockerhub)(保存镜像文件，提供上传，下载镜像)作用好比github\nDockerfile,将你部署项目的操作，写成一个部署脚本，这就是dockerfile,且该脚本还能够构建镜像文件\n\nDocker引擎\nDocker Daemon安装使用Docker,得先运行Docker Daemon进程，用于管理docker,如：\n\n镜像 images\n容器 containers\n网络 network\n数据卷 Data Volumes\n\nRest接口提供和Daemon交互的API接口\nDocker Client客户端使用REST API和Docker Daemon进行访问\nDocker平台组成\nImages镜像是一个只读模板，用于创建窗口，也可以通过Dockerfile文本描述镜像的内容镜像的概念类似于编程开发里面向对象的类，从一个基类开始(基础镜像Base Image)构建窗口的过程，就是运行镜像，生成容器的实例Docker镜像的描述文件是Dockerfile,包含了如下的指令\n\nFROM 定义了基础镜像\nMAINTAINER 作者\nRUN 运行Linux命令\nADD 添加文件&#x2F;目录\nENV 环境变量\nCMD 运行进程\n\nContainer容器是一个镜像的运行实例，镜像&gt;容器创建容器的过程\n\n获取镜像，如 docker pull contos,从镜像仓库拉取\n使用镜像创建容器\n分配文件系统，挂载一个读写层，在读写层加载镜像\n分配网络&#x2F;网桥接口，创建一个网络接口，让容器和宿主机通信\n容器获取IP地址\n执行容器命令，如&#x2F;bin&#x2F;bash\n反馈容器启动结果\n\nRegistryDocker镜像需要进行管理，docker提供了Registry仓库，其实它也是一个容器。可以基于该容器运行私有仓库。也可以使用Docker Hub互联网公有镜像仓库\nDocker的安装Docker引擎主要有两个版本：企业版(EE)和社区版(CE)\n安装环境初始化\n机器环境初始化\n# 1.防火墙# 2.yumidr# 3.安装基础软件wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repowget -O /etc/yum.repos.d/epel.repo https://mirrors.aliyun.com/repo/epel-7.repoyum clean allyum makecacheiptgables -F #清空系统规则getenforce #确保selinux也是处于禁用状态yum install -y bash-completion vim lrzsz wget expect net-tools nc nmap tree dos2unix htop iftop iotop unzip telnet sl psmisc nethogs glances bc ntpdate openldap-devel\n\n安装docker#docker必须安装在centos7平台，内核版本不低于3.10#在centos平台运行docker可能会遇见些警告信息，修改内核配置参数，打开内核转发功能uname -r\n\n开启Linux内核的流量转发\ncat &lt;&lt;EOF &gt; /etc/sysctl.d/docker.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1net.ipv4.conf.default.rp_filter = 0net.ipv4.conf.all.rp_filter = 0net.ipv4.ip_forward = 1EOFmodprobe br_netfilter# 加载修改内核的参数配置文件sysctl -p /etc/sysctl.d/docker.conf\n\n利用yum快速安装docker\n# 提前配置好yum仓库# 1.阿里云自带仓库 2.阿里云提供的docker专属repo仓库curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repocurl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 更新yum缓存yum clean all &amp;&amp; yum makecache # 可以直接yum安装docker了yum install docker-ce-20.10.6 -y# 查看源中可用版本yum list docker-ce --showduplicates | sort -r# 如果需要安装旧版本yum install -y docker-ce-18.09.9# 如果要卸载yum remove -y docker-xxx\n\n镜像加速器使用docker首要操作就是获取镜像文件，默认下载是从Docker Hub下载，网速较慢，国内很多云服务商都提供了加速器服务，阿里云加速器，Daocloud加速器，灵雀云加速器\n# 1.修改docker配置文件，我们选用七牛云镜像站cat /etc/docker/daemon.json# 也可以配置加速源https://cr.console.aliyun.com/cn-hangzhou/instances/mirrorsmkdir -p /etc/dockervi /etc/docker/daemon.json&#123;  &quot;registry-mirrors&quot; : [    &quot;https://8xpk5wnt.mirror.aliyuncs.com&quot;  ]&#125;# 2.重启，设置开机自启systemctl daemon-reloadsystemctl enable dockersystemctl restart dockerps -ef | grep dockerdocker psdocker images == docker image ls docker version # 看到Client和Server说明docker正确安装和启动成功了\n\n启动第一个docker容器# 先搜索镜像文件是否存在docker search nginx# 1.获取镜像，获取是从之前配置好的docker镜像站中，去拉取镜像docker pull nginx[:tag]# 2.运行镜像，生成容器,运行nginx镜像，运行出，具体的容器，容器中就跑着一个nginx服务了docker run 参数 镜像的名字/id# -d 后台运行容器# -p 80:80 端口映射 宿主机端口:容器端口  访问宿主机的这个端口，也就访问了容器内的端口netstat -tunlpdocker run -d -p 80:80 nginx # 会返回一个容器的id# 查看容器是否在运行docker ps# 此时可以访问宿主机的80端口，就访问到了容器内的80端口# 停止容器，查看结果docker ps docker stop 容器id# 开始运行docker start 容器id# 查看本地的docker镜像有哪些docker images# 删除镜像docker rmi 镜像id\n\ndocker的生命周期学习docker的核心要素，就是要搞明白镜像image,容器!\ndocker build . # 构建dockerfile生成镜像docker save 导出镜像docker load 导入镜像# 公司同事之间传递镜像文件，把镜像导出为一个压缩文件docker run 镜像 # 生成一个容器docker stop 容器id/名字docker start 容器id/名字docker restart 容器id/名字#当你在容器中，定制安装了些软件，想要提交该容器生成一个镜像docker commit 容器id# 1.获取了一个centos镜像，连vim都没有# 2.docker run centos,可以进入容器# 3.在容器中安装了一个vim# 4.docker commit 容器id# 5.提交后生成的镜像就是携带vim的镜像了\n\ndocker镜像的原理我们在获取redis镜像的时候，发现是下载了多行信息，最终获取了一个完整的镜像文件\ndocker pull redis# 会下载很多层docker images\n使用vmware虚拟机安装的系统，是一个完整的系统，包括2部分\n\nLinux内核，作用是提供操作系统的基本功能，和机器硬件交互\ncentos7发行版，作用是提供软件功能，例如yum安装包等\n\n因此，Linux内核+centos发行版，就组成了一个系统是否有一个办法，可以灵活的替换发行版，让我们使用不同的系统\ndocker就实现了这个功能，技术手段就是docker images\n# 查看发行版cat /etc/os-release# 查看内核版本uname -r# 利用docker获取不同的发行版镜像docker pull centos:7.8.2003docker pull ubuntu# 运行容器且进入容器内# -i 交互式操作 -t 开启一个终端 bash 进入容器后执行的命令docker run -it centos bashcat /etc/redhat-releaseexitdocker run -it ubuntu shcat /etc/lsb-releaseexitdocker search susedocker search opensusedocker pull opensusedocker imagesdocker run -it opensuse bashcat /etc/SuSE-releasehostname # 返回的是容器idexit\n小节\n\n一个完整的系统，是由Linux内核+发行版，才组成了一个可以使用的完整系统\n利用docker容器，可以获取不同的发行版镜像，然后基于该镜像，运行出各种发行版去使用\n\ndocker的好处\n\n解决了环境的兼容问题，在容器中运行Linux发行版，以及各种软件，[windows+docker+容器1(centos)+容器2(ubuntu)]\n环境很干净，安装的所有内容，都在容器里，不想要了，直接删除容器，不影响宿主机\n比如想把mysql容器内的数据，配置，全部迁移到服务器上，只需要提交该容器，生成镜像，镜像放到服务器上，docker run 就可以了。\n\n\nUnion File Systemdocker通过联合文件系统，将上述的不同的每一层，整合为一个文件系统，为用户隐藏了多层的视角。当通过一个image启动容器时，docker会在该image最顶层，添加一个读写文件系统作为容器，然后运行该容器docker镜像本质是基于UnionFS管理的分层文件系统dockerfile的作用：自定义docker镜像的每一层作用\n\ndocker镜像定义我们如果自定义镜像，docker镜像不包含Linux内核，和宿主机共用。我们想要定义一个mysql5.6镜像，我们会这么做\n\n获取基础镜像，选择一个发行版平台(ubuntu,centos)\n在centos镜像中安装mysql5.6软件\n\n导出镜像，可以命名为mysql:5.6镜像文件。从这个过程，我们可以感觉出这是一层一层添加的，docker镜像的层级概念就出来了，底层是centos镜像，上层是mysql镜像，centos镜像层属于父镜像。\nDocker镜像是在基础镜像之后，安装软件，配置软件，添加新的层，构建出来。dockerfile构建时，更加清晰。\n# 查看正在运行的容器docker ps# 进入到正在运行的容器内docker exec -it 容器id bash\n\ndocker镜像为什么分层镜像分层的一大好处就是共享资源，例如有多个镜像都来自于同一个base镜像，那么在docker host只需要存储一份bash镜像。\n内存里也只需要加载一份host,即可为多个容器服务。\n即使多个容器共享一个base镜像，某个容器修改了base镜像的内容，如修改&#x2F;etc&#x2F;下配置文件，其他容器的&#x2F;etc&#x2F;下的内容是不会被修改的，修改动作只限制在单个容器内，这就是容器的写入时复制特性(Copy-on-write)\n可写的容器层当容器启动后，一个新的可写层被加载到镜像的顶部，这一层通常被称为容器层，容器层下的都称为镜像层\n对所有容器的修改操作，都只会发生在容器层里，只有容器层是可写的，其余镜像层都是只读的。\n\n添加文件  容器中创建文件时，新文件被添加到容器层中。\n读取文件  在容器中读取某个文件时，Docker会从上往下依次在各镜像中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存\n修改文件  在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后改之。\n删除文件  在容器中删除文件时，Docker会从上往下依次在各镜像层中查找此文件。找到后，会在容器层中记录下此删除操作(只是记录删除操作)\n\n只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write.可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。\n容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享\nDocker镜像的内容docker镜像层级管理的方式大大便捷了Docker镜像的分发和在存储。Docker hub是为全世界的镜像仓库。\n\nDocker镜像代表一个容器的文件系统内容\n镜像层级技术属于联合文件系统\n容器是一个动态的环境，每一层镜像里的文件都属于静态内容\ndockerfile里的ENV,VOLUME,CMD等内容都会落实到容器环境里\n\n\n\ndocker镜像的实际使用学习1.下载安装docker工具2.获取该软件的docker镜像，下载nginx镜像，docker pull nginx3.运行该镜像，启动了容器，这个nginx就运行在容器中4.停止容器，删除镜像，就好像没有安装过nginx一样就好比沙箱一样的环境基于镜像的增删改查\n获取镜像# 1.获取镜像，镜像托管仓库，就好比yum源一样# 默认的docker仓库是，dockerhub,有大量的优质镜像，以及用户上传的镜像，centos容器安装vim nginx ...提交镜像，上传到dockerhubdocker search 镜像名:tag tag就是具体的标签版本docker version docker psdocker images == docker image lsdocker search centosdocker pull centosdocker images# 下载镜像文件docker pull centos # 默认是centos:latestdocker pull centos:7.8.2003# 查看docker数据的存放目录docker info [ | grep Root]ls /var/lib/dockerdocker imagesls /var/lib/docker/image/overlay2/imagedb/content/sha256# 这里面的id是和docker images查看出来的id是一样的# 查看id，内容是json格式的数据# 作用是记录 镜像 和容器的配置关系# 使用不同的镜像生成容器# -it 开启一个交互式的终端，--rm 容器退出时删除该容器docker run -it --rm centos bashexitdocker imagesdocker run -it --rm centos:7.8.2003 bash\n\n查看镜像docker images ## 查看具体的镜像docker images centosdocker images ubuntu# 可以指定具体的tagdocker images centos:7.8.2003# 只列出镜像的id# -q --quiet 只列出iddocker images -q # 格式化显示镜像 这里docker 的模板语言 --formatdocker images --format &quot;&#123;&#123;.ID&#125;&#125;--&#123;&#123;.Repository&#125;&#125;&quot;# 以表格形式显示，美化docker images --format &quot;table &#123;&#123;.ID&#125;&#125;\\t&#123;&#123;.Repository&#125;&#125;\\t&#123;&#123;.Tag&#125;&#125;&quot;# 搜索dockerhub的镜像docker search 镜像名\n\n删除镜像# 镜像加速curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.iodocker version &gt;=1.12&#123;&quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;]&#125;Success.You need to restart docker to take effect: sudo systemctl restart dockersudo systemctl restart docker# 下载docker pull hello-worlddocker imagesdocker run hello-world# 根据镜像的id,名字，摘要等 docker images hello-world# 被删除的镜像不得有依赖容器的记录docker rmi hello-worlddocker ps -a # 删除容器记录docker rm 容器id# 指定id的前三位即可docker rmi d11\n\n镜像管理docker images# 列出所有的镜像docker images -a# 列出所有的镜像id docker images -aqecho `docker images -aq`# 指删除镜像，慎用docker rmi `docker images -aq`docker rm `docker ps -aq`# 导出镜像docker run -it centos bash# 比如默认运行的centos镜像，不提供vim功能，运行该容器后，在容器内安装vimyum install -y vim # 然后提交该镜像，再导出该镜像为压缩文件，可以发给其他人用exitdocker ps -a# 导出镜像的命令docker imagesdocker image save centos:7.8.2003 &gt; /opt/centos7.8.2003.tgz# 导入镜像的命令docker image load -i /opt/centos7.8.2003# 查看镜像详细信息docker info #看的是docker 进程的信息docker image inspect 镜像id\n\ndock容器docker run 等于创建+启动docker run 镜像名，如果镜像不存在本地，则会在线去下载该镜像\n注意：容器内的进程必须处于前台运行状态，否则容器就会退出，自己部署一个容器运行，命令不得后台运行，前台运行即可如果容器内，什么事也没做，容器也会挂掉，容器内必须有一个进程在前台运行我们运行nginx基础镜像，没有运行任何程序，因此容器直接挂掉\nnohub ping baidu.com &amp;jobs # 查看后台运行的程序fg 1 # 把后台运行的程序提到前台# 运行容器的玩法# 1.运行一个挂掉的容器docker run centos:7.8.2003# 这个写法，会产生多条独立的容器记录，且容器内没有程序在跑，因此挂了# 2.运行容器，且进入容器内，且在容器内执行某个命令docker run -it centos:7.8.2003 sh# 3.开启一个容器，让它帮你运行某个程序，属于前台运行，会卡住一个终端docker run centos:7.8.2003 ping baidu.com# 4.运行一个活着的容器，docker ps可以看到的容器# -d参数，让容器在后台跑着（针对宿主机而言）docker run -d centos:7.8.2003 ping baidu.comdocker ps #可以看到# 5.丰富docker运行的参数# -d 后台运行# --rm 容器挂掉后自动被删除# --name 给容器起个名字docker run -d --rm centos:7.8.2003 ping baidu.comdocker psdocker run -d --rm --name baidu centos:7.8.2003 ping baidu.comdocker psdocker stop 容器iddocker ps -a 也看不到，因为被删除了# 6.查看容器的日志# -f 动态跟踪docker logs -f  容器id# 7.进入正在运行的容器空间内docker exec -it 容器id bash # 8.查看容器的详细信息docker container inspect 容器id # 返回的是json数据串# 9.容器的端口映射docker run -it nginx netstat -tunlp | grep 80 # 此时是不能访问到容器内的nginx的#后台运行nginx容器，起个名字，且端口映射宿主机的85端口，访问到容器内的80端口docker run -d --name my_nginx -p 85:80 nginxdocker ps# 随机端口映射 -P 随机访问一个宿主机的空闲端口，映射到容器内打开的端口docker run -d --name my_nginx_random -P nginx # 10.容器的提交# 运行基础的centos:7.8.2003 ，在容器内安装vim，然后提交新的镜像# 新的镜像，再运行出的容器，默认就带有vim了docker run -it centos:7.8.2003 bash# 提交容器docker commit 容器记录的id 自定义的镜像名docker images # 就可以查看到# 再运行新的镜像，就带有vim\n\nDockerFile镜像定制定制docker镜像的方式有两种\n\n手动修改容器内容，导出新的镜像\n基于Dockerfile自行编写指令，基于指令流程创建镜像\n\nDockerfile简介镜像是多层存储，每一层在前一层的基础上进行修改容器也是多层存储，以镜像为基础层，在其基础上加一层作为容器运行时的存储层。\n\n手动修改容器内容，然后docker commit 提交容器为新的镜像\n通过在dockerfile中定义一系列的命令和参数构成的脚本，然后这些命令应用于基础镜像层，依次添加层，最终生成一个新的镜像。极大简化了部署工作\n\n官方提供的dockerfile实例https://github.com/CentOS/CentOS-Dockerfiles\ndockerfile的主要组成部分：\n基础镜像信息 FROM centos:6.8制作镜像操作指令RUN yum install openssh-server -y容器启动时执行指令 CMD [&quot;/bin/bash&quot;]\n\ndockerfile 指令FROM 指定基础镜像MAINTAINER 指定维护者信息，可以没有RUN 你想让它做什么（在命令前面加上RUN即可）ADD 添加宿主机的文件到容器内，还多了一个自动解压的功能# RUN tar -zxf /opt/xxx.tgz # 报错！该tgz文件不存在！COPY 添加宿主机的文件到容器内，仅仅拷贝WORKDIR 设置当前工作目录VOLUME 设置卷，挂载主机目录EXPOSE 指定对外的端口CMD 指定容器启动后要做的事\ndocker其他指令：\nCOPY 复制文件ENV 环境变量ENTRYPOINT 容器启动后执行的命令\n\n# 1.创建Dockerfile，注意文件名必须是这个vim DockerfileFROM nginxRUN echo &#x27;nginx首页&#x27; &gt; /usr/share/nginx/html/index.html# 2.构建dockerfile,在Dockerfile文件相同的文件夹docker build .# 3.修改镜像名docker tag 镜像id 名字# 4.运行该镜像netstat -tunlpdocker imagesdocker psdocker run -d -p 80:80 my-nginx# 5.查看宿主机的80端口ip:80\n\nCOPY# copy指令从宿主机复制文件到/目录到新的一层镜像内copy xxx.py /home/# 支持多个文件，以及通配符形式复制，语法要满足Golang的filepath.Matchcopy xxx* /tmp/cc?.txt /home/# COPY指令能够保留源文件的元数据，如权限，访问时间等\n\nADD特性和COPY一致，不过多了些功能1.源文件是一个URL,此时docker引擎会下载该链接，放入目标路径，且权限自动设为600,若这不是期望的结果，还要增加一层RUN指令进行调整2.源文件是一个URL,且是一个压缩包，不会自动解压，需要单独用RUN命令解压3.源文件是一个压缩文件，且是gzip,bzip2,xz,tar情况，ADD指令会自动解压缩该文件到目标路径\nDockerfile官方更推荐用COPY,ADD包含了更多复杂的功能，且ADD会使构建缓存失效，导致镜像构建缓慢\nCMD用法，注意是双引号CMD [&quot;参数1&quot;,&quot;参数2&quot;]在指定了entrypoint指令后，用CMD指定具体参数docker不是虚拟机，容器就是一个进程，既然是进程，那么程序在启动的时候需要指定些运行参数，这就是CMD指令的作用# 该镜像在运行容器实例的时候，执行的具体参数是什么例如centos镜像默认的CMD是/bin/bash，直接docker run -it centos 会直接进入bash解释器。也可以启动容器的时候，指定参数。docker run -it centos cat /etc/os-releaseaCMD运行shell命令，也会被转化为shell形式例如CMD echo $PATH会被转化为CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo $PATH&quot;]\n\n容器内运行程序这里要注意的是，docker不是虚拟机的概念，虚拟机里的程序运行，基本上都是在后台运行，利用systemctl运行，但是容器内没有后台进程的概念，必须在前台运行容器就是为了主进程而存在的，主进程如果退出了，容器也就失去了意义，自动退出例如有一个经典的问题\nCMD systemctl start nginx这样的写法是错误的，容器会产即退出因为systemctl start nginx 是希望以守护进程形式启动nginx,且CMD命令也会转化为CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;systemctl start nginx&quot;]这样的命令主进程是sh解释器，执行完毕后产即结束了，因此容器也就退出了正确的做法应该是CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]\n\nENTRYPOINT和RUN指令一样，分为两种格式\n\nexec\nshell\n\n作用和CMD一样，都是在指定容器启动程序以及参数当指定了ENTRYPOINT之后，CMD指令的语义就有了变化，而是把CMD的内容当作参数传递给ENTRYPOINT指令\n# 实际用法# 1.准备好dockerfillvim DockerfileFROM centos:7.8.2003RUN rpm --rebuilddb &amp;&amp; yum install epel-release -yRUN rpm --rebuilddb &amp;&amp; yum install curl -yCMD [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ipinfo.io/ip&quot;]# 2.构建镜像docker build .# 3.查看结果Successfully build 镜像id# 4.检查镜像docker tag 镜像id centos_curldocker images # 5.运行镜像，生成容器 生成的只是容器记录docker run centos_curl# 6.上述运行正确，但是想再传入一个参数，发现是无法传入参数的,该形式是覆盖镜像中cmddocker run centos_curl -I# 报错docker run centos_curl pwd/# 7.想要正确的给容器传入一个-I参数,希望容器内能正确完整的执行下面命令curl -s http://ipinfo.io/io -I# 8.解决办法给容器传入新的，完整的命令docker run centos_curl curl -s http://ipinfo.io/io -I可以正确运行，但是没有意义# 9.正确的做法应该是使用ENTRYPOINT修改Dockerfile,如下vim DockerfileFROM centos:7.8.2003RUN rpm --rebuilddb &amp;&amp; yum install epel-release -yRUN rpm --rebuilddb &amp;&amp; yum install curl -yENTRYPOINT [&quot;curl&quot;,&quot;-s&quot;,&quot;http://ipinfo.io/ip&quot;]# 10.重新构建Dockerfiledocker build .# 11.重新运行镜像，看结果，以及传入新的参数# 此时发现，传入的CMD指令，当做了ENTRYPOINT的参数，容器内执行的完整命令是curl -s http://ipinfo.io/ip -Idocker run centos_crul_new -I\n\nARG和ENV指令设置环境变量\nDockerfile脚本，shell脚本ENV NAME=&quot;name&quot;ENV AGE=&quot;19&quot;ENV MYSQL_VERSION=5.6后续所有操作，通过$NAME 就可以直接获取变量了，维护Dockerfile脚本时更友好，方便ARG和ENV一样 设置环境变量 区别在于ENV无论是在镜像构建时，还是在容器运行时，该变量都可以使用ARG只是用于构建镜像需要设置的变量，容器运行时就消失了\n\nVOLUE容器在运行时，应该保证在存储层不写入任何数据，运行在容器内产生的数据，我们推荐是挂载，写入到宿主机上，进行维护\nVOLUME /data # 将容器内的/data文件夹，在容器运行时该目录自动挂载为匿名卷，任何向该目录中写入数据的操作，都不会被容器记录，保证容器存储层的无状态理念# DockerfileFROM centosMAINTAINER fengVOLUME [&quot;/data1&quot;,&quot;/data2&quot;]# 该容器运行时，这两个目录自动和宿主机的目录做好映射关系docker build .# 运行该镜像docker run 镜像id# 查看生成的容器信息docker ps -a | head -2# docker inspect 命令查看docker inspect 容器id\n1.容器数据挂载的方式，通过dockerfile,指定VOLUME目录2.通过docker run -v 参数，直接设置需要映射挂载的目录\nEXPOSE指定容器运行时对外提供的端口服务\n\n帮助使用该镜像的人，快速理解该容器的一个端口业务\n\ndocker port 容器docker run -p 宿主机端口:容器端口docker run -P # 作用是随机宿主机端口:容器端口\n\nWORKDIR用于在Dockerfile中，目录的切换，更改工作目录\nWORKDIR /opt\n\nUSER用于改变环境，用于切换用户\nUSER rootUSER feng\n\n","categories":["docker"],"tags":["docker"]},{"title":"git命令","url":"/2023/02/10/git%E5%91%BD%E4%BB%A4/","content":"git忽略文件git update-index --assume-unchanged [file-path]# 恢复文件git update-index --no-assume-unchanged [file-path]git ls-files -v | grep &#x27;^h\\ &#x27;\n仓库# 在当前目录新建一个Git代码库git init# 新建一个目录，将其初始化为Git代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url]\n\n配置# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;\n\n增加&#x2F;删除文件# 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]\n代码提交# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...\n分支# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]\n标签# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]\n查看信息# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog\n远程同步# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all\n撤销# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]\n\n暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop\n其他# 生成一个可供发布的压缩包$ git archive# git bash 显示中文git config --global core.quotepath false# git——.gitignore添加忽略文件不生效原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交，这样就不会出现忽略的文件了。git清除本地缓存命令如下：git rm .env.development --cached在这里插入图片描述git commit -m &quot;Stopped tracking .env.development&quot;在这里插入图片描述现在，你应该可以随意修改.env.development文件，而不会受到git的跟踪了，这样每次提交都不会提交.env.development的修改到git上了解决Git中fatal: refusing to merge unrelated histories这是因为两个分支没有取得关系在你操作命令后面加--allow-unrelated-histories例如：git merge master --allow-unrelated-histories同理：git pull origin master --allow-unrelated-histories\ngit命令修改远程仓库HTTPS 协议git remote set-url origin https://gitee.com/uncleyong/javaAutoTest.gitSSH 协议git remote set-url origin &#103;&#x69;&#x74;&#64;&#x67;&#105;&#116;&#x65;&#x65;&#x2e;&#x63;&#x6f;&#x6d;:uncleyong&#x2F;javaAutoTest.git\n解决每次git pull、git push都需要输入账号和密码的问题git config --global credential.helper store当前仓库不加 --global这次还要输入，下次就不用了\n提交部分代码#git只提交部分修改的文件（提交指定文件）git status -s 查看仓库状态git add src/components/文件名 添加需要提交的文件名(加路径–参考git status-打印出来的文件路径)gi stash -uk 忽略其他文件，把现修改的隐藏起来，这样提交的时候就不会提交未被add的文件git commit -m “哪里做了修改可写人……”git pull 拉取合并git push 推送到远程仓库git stash pop 恢复之前忽略的文件(非常重要的一步)\n\ngit stash# 查看储藏记录列表git stash liststash@&#123;index&#125;: WIP on [分支名]: [最近一次的commitID] [最近一次的提交信息]# 隐藏时指定保存信息git stash save [stashMessage]# 隐藏部分文件git stash push &lt;file1&gt; &lt;file2&gt;\n\n取出储藏前文提到的可以通过git stash pop用于取出最近一次储藏的修改到工作区，而通过查看储藏列表的index的可以取出指定储藏中的修改到工作区\n# 取出指定index的储藏的修改到工作区中git stash apply stash@&#123;index&#125; # 将指定index的储藏从储藏记录列表中删除git stash drop stash@&#123;index&#125;\n\ngit stash 部分文件git stash push &lt;file1&gt; &lt;file2&gt; -m &quot;保存信息&quot;\n","categories":["git"],"tags":["git"]},{"title":"Hello World","url":"/2022/12/18/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":["blog"],"tags":["blog"]},{"title":"knowledge","url":"/2023/02/09/knowledge/","content":"“潜移默化，人方受教；斥其无知，不如称其易忘。”\nLog4J的输出级别按降序排序如下：OFF            最高等级，关闭日志\nFATAL          可能导致应用中止的严重事件错误 \nERROR          严重错误，主要是程序错误 \nWARN           一般警告 \nINFO           一般显示信息 \nDEBUG          调试信息 \nTRACE          比DEBUG更细粒度的事件信息 \nALL            最低等级\n\nOracle链接字符串\noracle两张表关联更新 update TA a set(name, remark)&#x3D;(select b.name, b.remark from TB b where b.id&#x3D;a.id)   where exists(select 1 from TB b where b.id&#x3D;a.id)注意如果不添加后面的exists语句，TA关联不到的行name, remark栏位将被更新为NULL值， 如果name, remark栏位不允许为null，则报错。 这不是我们希望看到的。当两张表的关系不是一对一时，用下面的方法\nmerge into  a using (select max(b.zj) zj,b.id from  b group by b.id) table2on (a.id=b.id)when matched thenupdate set a.zj=table2.zj\n\noracle 中，怎么在字符串中指定的位置插入一个字符可以用SUBSTR函数，来解决SUBSTR（‘AAAAA’，1，2）||‘ BBB‘||SUBSTR（’AAAAA‘，3）\noracle修改表字段长度alter table 表名 modify 列名 数据类型；alter table bl_yhsz modify  zcmc varchar2(120);\nOracle 字符串的截取substr(String,start,[length])\nlong类型的转换为String类型。CREATE OR REPLACE fUNCTION LONG_TO_CHAR(in_rowid      rowid, --rowid                                        in_owner      varchar, --所有者   可空                                        in_table_name varchar, --表名                                        in_column     varchar2 --要查询的列名                                        ) RETURN varchar AS  text_c1 varchar2(32767);  sql_cur varchar2(2000);begin  if length(in_owner) &gt; 0 then    sql_cur := &#x27;select &#x27; || in_column || &#x27; from &#x27; || in_owner || &#x27;.&#x27; ||               in_table_name || &#x27; where rowid = &#x27; || chr(39) || in_rowid ||               chr(39);  else    sql_cur := &#x27;select &#x27; || in_column || &#x27; from &#x27; || in_table_name ||               &#x27; where rowid =&#x27; || chr(39) || in_rowid || chr(39);  end if;  dbms_output.put_line(sql_cur);  execute immediate sql_cur    into text_c1;  text_c1 := substr(text_c1, 1, 4000);  RETURN TEXT_C1;END;\n\nselect t1.Table_Name || chr(13) || t3.comments as 表名称及说明,\t--t3.comments as 表说明,\tt1.Column_Name as 字段名称,\tt1.DATA_TYPE || &#x27;(&#x27; || t1.DATA_LENGTH || &#x27;)&#x27; as 数据类型,\tt1.NullAble as 是否为空,\tt2.Comments as 字段说明,\tt1.Data_Default as 默认值,\t--t4.created as 建表时间from cols t1left join user_col_comments t2\ton t1.Table_name = t2.Table_name\tand t1.Column_Name = t2.Column_Nameleft join user_tab_comments t3\ton t1.Table_name = t3.Table_nameleft join user_objects t4\ton t1.table_name = t4.OBJECT_NAMEwhere not exists (select t4.Object_Name\tfrom User_objects t4\twhere t4.Object_type = &#x27;TABLE&#x27;\tand t4.Temporary = &#x27;Y&#x27;\tand t4.Object_Name = t1.Table_Name)and t4.OBJECT_NAME IN (&#x27;表名大写&#x27;)order by t1.Table_Name,T1.colunm_id;\t\n\noracle  关于表中有clob字段的数据备份create table xxx as (select * from 原表名 where 条件);这样就可以备份clob字段了。\noracle 排序时把null放开头 order by xxx desc null first把null放末尾 order by xxx desc nulls last\n\n查询指定用户下的表和视图select table_name from all_tables where owner = &#x27;用户&#x27;;select view_name from dba_views where owner = &#x27;用户&#x27;;\ngroup by之后删除重复的数据先把group by 之后的数据，加上max(rowid)插入到一张临时新表中\ncreate table temp as (select max(rowid) maxrowid,xxx from a group by xxx) \n删除原表rowid不是最大rowid的数据，记得关联关系\ndelete from a where a.rowid not in (select maxrowid from temp) and a.xxx in (select xxx from temp)\n\n违反完整约束条件 未找到父项关键字把要插入表的外键关联给去掉，数据就可以导入进去了\noracle视图添加注释create or replace view org_user_view asselect t.username,t.password from org_users;comment on column org_user_view.usernameis &#x27;用户名;comment on column org_user_view.password is &#x27;密码&#x27;; \nnvlNVL函数是一个空值转换函数  NVL（表达式1，表达式2）  如果表达式1为空值，NVL返回值为表达式2的值，否则返回表达式1的值。该函数的目的是把一个空值（null）转换成一个实际的值。其表达式的值可以是数字型、字符型和日期型。但是表达式1和表达式2的数据类型必须为同一个类型。  对数字型： NVL（ comm,0);  对字符型 NVL( TO_CHAR(comm), &#x27;No Commission&#x27;)  对日期型 NVL（hiredate,&#x27; 31-DEC-99&#x27;)\nnvl2NVL2(表达式1，表达式2，表达式3）  如果表达式1为空，返回值为表达式3的值。如果表达式1不为空，返回值为表达式2的值。\n修改用户名1、用sysdba账号登入数据库，然后查询到要更改的用户信息：SELECT user#,name FROM user$;2、更改用户名并提交：UPDATE USER$ SET NAME=‘新的用户名’ WHERE user#=71;  COMMIT;3、强制刷新：ALTER SYSTEM CHECKPOINT;  ALTER SYSTEM FLUSH SHARED_POOL;4、更新用户的密码：ALTER USER 新用户名 IDENTIFIED BY &#x27;密码&#x27;;\n是否有效不确定之前用sqlplus &#x2F; as sysdba登录后，执行第二个，提示权限不足。\niframeWhen I first tried this method, I got a lame error about an IFRAME element’s contentWindow property being null.  Ugh.  It didn’t take long to figure out why:  you need to wait until the IFRAME has loaded to get the contentWindow:\nvar iframe = document.createElement(&#x27;iframe&#x27;);iframe.onload = function() &#123;\t// contentWindow is set!\t&#125;;iframe.src = &#x27;about:blank&#x27;;document.body.appendChild(iframe);\nOf course you’ll want to add the onload event before setting the src.  If you use the load event to check for the contentWindow property, you’ll be in business!\njavaSimpleDateFormat 格式日期出错 时间不对得问题将日期格式是 2019-09-09类型得字符串格式成20190909时如果直接用SimpleDateFormat(“yyyyMMdd”)进行格式 会出现日期错误得情况应该先将字符串转换成SimpleDateFormat(“yyyy-MM-dd”)类型得日期再进行格式化\n之前遇到的日期问题。public String changeTime(String time)&#123;\tif(time == null )&#123;return null&#125;\tString format1=null,format2=null;\tif(time.length()==8)&#123;\t\tformat1=&quot;yyyyMMdd&quot;;\t\tformat2=&quot;yyyy-MM-dd&quot;;\t&#125;else if(time.length()==14)&#123;\t\tformat1=&quot;yyyyMMddHHmmss&quot;;\t\tformat2=&quot;yyyy-MM-dd HH:mm:ss&quot;;\t&#125;else&#123;\t\tformat1=&quot;yyyy-MM-dd HH:mm:ss&quot;;\t\tformat2=&quot;yyyy-MM-dd HH:mm:ss&quot;;\t&#125;\treturn DateTimeUtils.DatetoString_format(DateTimeUtils.DatetoString_Format(time,format1),format2);&#125;\n取当前月的最后一天Calender calender = Calender.getInstance();calender.setTime(new Date());calender.add(Calender.MONTH,1);//当前日期的后一个月calender.set(Calender.DAY_OF_MONTH,1);//获取后一个月的第一天calender.add(Calender.DAY_OF_MONTH,-1);//后一个月的前一天Date date = calender.getTime();\nSpring boot增加上下文路径server:   port: 8080  servlet:     context-path: name\n配置文件如果 properties和 yml 文件都存在，不存在 spring.profiles.active 设置，如果有重叠属性，默认以 properties 优先。如果设置了 spring.profiles.active，并且有重叠属性，以 active 设置优先。\njava对象的copyorg.springframework.beans.BeanUtils.copyProperties(源对象,目标对象);//1、org.apache.commons.beanutils.BeanUtils和org.springframework.beans.BeanUtils两个包中的copyProperties方法目标对象和源对象参数的位置是相反，使用时需要注意。//2、使用org.apache.commons.beanutils.BeanUtils进行copy对象时，被copy的对象（source/orig）中包含的字段目标对象（target/dest）必须包含，可以有其他的多于字段，类型可以不相同，但字段名称必须一致；org.springframework.beans.BeanUtils中的没有这个限制。\n在实体类里面调用serviceTestServiceImpl test = appContext.getBean(TestServiceImpl.class);\n下载不能用ajax，直接使用window.location&#x3D;””;BigDecimalBigDecimal data = new BigDecimal(&quot;10&quot;);必须要用string类型赋值，而不能用float和double.加法 add()函数 减法 subtract()函数乘法 multiply()函数 除法 divide() 函数 绝对值abs()函数大小的比较a.compareTo(b) == 1   a&gt;ba.compareTo(b) == 0   a=ba.compareTo(b) == -1  a&lt;b\n\nidea ssm 项目导出成war包1.先选项目结构，点击artifacts,再点+，选择Web Application: Archive–&gt; Empty2.修改项目名，类型，输出文件夹，点击xxx.war，create,点击右边的文件，put into Output Root，apply3.点击Build，选择Build Artifacts，Build。如果导出的war包大小不正确，先Rebuild Project ，再Clean Artifacts, 再重新打包\njava -jar 参数配置nohup java -jar -Xms1024m -Xmx1024m -Xss256k -XX:MetaspaceSize=256m -XX:MaxMetaspaceSize=512m xxx.jar --spring.profiles.active=xxx &gt; /dev/null 2&gt;&amp;1 &amp;\n\n注解为@RequestPart时postman调用方法 headerContent-type multipart/form-databodyparamName xxx.json() --这个是文件\nsql查询有记录，但都是null这里附给对应的vo也为null\ntomcat报400java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义\n【Tomcat】已解决：java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义\n[http-nio-8080-exec-7] org.apache.coyote.http11.Http11Processor.service 解析 HTTP 请求 header 错误 注意：HTTP请求解析错误的进一步发生将记录在DEBUG级别。    java.lang.IllegalArgumentException: 在请求目标中找到无效字符。有效字符在RFC 7230和RFC 3986中定义        at org.apache.coyote.http11.Http11InputBuffer.parseRequestLine(Http11InputBuffer.java:509)        at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:511)        at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:65)        at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:831)        at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1650)        at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)        at org.apache.tomcat.util.threads.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1191)        at org.apache.tomcat.util.threads.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:659)        at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)        at java.lang.Thread.run(Thread.java:748)\n方案一、Tomcat官网给出的方案：http://tomcat.apache.org/tomcat-8.0-doc/config/systemprops.html\ntomcat.util.http.parser.HttpParser. requestTargetAllow\nThis system property is deprecated. Use the relaxedPathChars and relaxedQueryChars attributes of the Connector instead. These attributes permit a wider range of characters to be configured as valid.\nA string comprised of characters the server should allow even when they are not encoded. These characters would normally result in a 400 status.\nThe acceptable characters for this property are: |, { , and }\nWARNING: Use of this option may expose the server to CVE-2016-6816.\nIf not specified, the default value of null will be used.\n方案二、修改server.xml 配置\ntomcat –&gt; conf–&gt; server.xml \n&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;\n           connectionTimeout=&quot;20000&quot;\n           redirectPort=&quot;8443&quot;\n           URIEncoding=&quot;utf-8&quot; relaxedPathChars=&quot;|&#123;&#125;[],%&quot;\n           relaxedQueryChars=&quot;|&#123;&#125;[],%&quot;\n           /&gt;\n\ntomcat 启动参数 Xms, Xmxlinux 在 tomcat/bin/catalina.sh 的 第一行#!/bin/sh 下添加JAVA_OPTS = &quot;-server -Xms1024m -Xmx2048 -XX:MaxNewSize=512m -XX:PermSize=128m -XX:MaxPermSize=256m -Djava.awt.headless=true&quot;windows 是.bat下面JAVA_OPTS = -Xms1024m -Xmx2048\n\njsenter事件把下面的方法添加到页面加载的函数中\nfunction addEnterEvent()&#123;\t$(&quot;#id&quot;).keydown(function (envnt)&#123;\t\tif(event.keyCode ==13)&#123;\t\t\tsearch();\t\t&#125;\t&#125;)&#125;\n向后台传递日期，后台获取不到问题jsp页面如果用日期控件获取到日期后台接收为Date类型前台把日期转成字符串格式，再向后台传\nvar date = new Date();var year = date.getFullYear();var month = date.getMonth()+1;var day = date.getDate();var date1 = year+&quot;-&quot;+month+&quot;-&quot;+day;把date1传递给后台，后台就可以接收到\n多选框默认选中$(&quot;#id&quot;).setValue(true);\n移除属性document.getElementById(&quot;id&quot;).removeAttribute(&quot;属性&quot;);$(&quot;#id&quot;).removeAttr(&quot;属性&quot;);\n弹出确认框$.prompt();\n向数组中添加元素var array = [];array.push(1);array.push(1);array = [1,1];\n添加相同的元素，不会被覆盖\nmybatis转义&lt;![CDATA[ 字段 &lt;&gt; 0 ]]&gt;\nsql数量和list数量不一致在sql语句里面添加查询主键。如：sys_guid()\n数据库类型为NUMBER在mybatis里面jdbcType可以写成NUMERIC\n单个参数出现 There is no getter for property named ‘name’ in ‘class java.lang.String’的问题There is no getter for property named &#x27;*&#x27; in &#x27;class java.lang.String，此错误之所以出现，是因为mybatis在对parameterType=&quot;String&quot;的sql语句做了限制，假如你使用&lt;when test=&quot;username != null&quot;&gt;这样的条件判断时，就会出现该错误，解决办法需要把 &lt;when test=&quot;username != null&quot;&gt;修改为 &lt;when test=&quot;_parameter  != null&quot;&gt;就好了\n\n数据比较&lt;if test=&quot;a != null and a == 0.toString()&quot;&gt;&lt;/if&gt;&lt;foreach collection=&quot;ids.split(&#x27;,&#x27;)&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;item&quot;&gt;\t&lt;if test=&quot;item==0&quot; &gt; sql &lt;/if&gt;&lt;/foreach&gt;&lt;!-- 如果collection里面的是数组，要先在外面用if判断null --&gt;\n","categories":["java"],"tags":["java"]},{"title":"博客仓库克隆","url":"/2023/03/25/%E5%8D%9A%E5%AE%A2%E4%BB%93%E5%BA%93%E5%85%8B%E9%9A%86/","content":"安装博客需要的工具sudo pacman -S nodejs npm node -vnpm -v\n\n利用npm安装cnpmsudo npm install -g cnpm --registry=https://registry.npm.taobao.orgsudo cnpm install -g hexo-clihexo -v\n\ngit clone 下来后cd bloghexo clean 报错#按提示执行下面命令 rm -rf node_modules &amp;&amp; cnpm install --forcesudo hexo cleanError: Cannot find module &#x27;hexo-util&#x27;cnpm install hexo-util --savesudo hexo gNo layout: index.htmlrm -rf themes/arknights#克隆主题git clone https://github.com/Yue-plus/hexo-theme-arknights.git themes/arknights#主题依赖的安装cnpm install hexo-server hexo-browsersync hexo-renderer-pug --savesudo hexo shttps://localhost:4000\n可以查看到博客内容说明克隆成功\n部署到远端cnpm install --save hexo-deployer-git#ssh-add ~/.ssh/id_rsa#ssh-agent bashssh-keygen -t rsa#用原来的旧的公私钥替换掉新的#确保new上的两个文件的权限，id_rsa 600 id_rsa.pub 644chmod 600 id_rsassh-agent -sssh-add ~/.ssh/id_rsassh -T git@github.com\n","categories":["blog"],"tags":["blog"]},{"title":"博客相关配置","url":"/2022/12/20/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","content":"hexo d 报错修改\n_config.yml 最后面的deploy    deploy:     type: &#x27;git&#x27;     repo: git@github.com:ucgfeng/ucgfeng.github.io.git     branch: main.deploy_git/.git/config\n\n\nblog 主题安装依赖git clone https://github.com/Yue-plus/hexo-theme-arknights.git themes/arknights\nnpm 用户：\ncnpm install hexo-server hexo-browsersync hexo-renderer-pug --save\n修改配置文件参照 Hexo 官网 修改 Hexo&#x2F; 目录下的 _config.yml。\n把 theme: 的值改为 arknights开启代码高亮：highlight:  hljs: true剪切 Hexo&#x2F;themes&#x2F;arknights&#x2F;_config.yml 到 Hexo 目录下，并重命名为 _config.arknights.yml。\n建议参考：使用代替主题配置文件主题的配置文件可参照中文注释修改。\n博客上传图片在source 下创建 pics 文件夹\n在md文件里写路径 时，前面记得加 &#x2F; ，如：![](/pics/xxx.png)\n","categories":["blog"],"tags":["blog"]}]