<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>docker | ffc's blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - 共 $1 行","copy":"复制","copyFinish":"复制成功","expand":"展开"}}</script><script src="//unpkg.com/mermaid@9.2.2/dist/mermaid.min.js"></script><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/brands.min.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/fontawesome.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light') document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark') document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: BenderLight;
 src: local('Bender'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Brands';
 src: local('Font Awesome 6 Brands'), url('/lib/fontawesome/fa-brands.woff2') format('woff2');
}
@font-face {
 font-family: 'Font Awesome 6 Free';
 src: local('Font Awesome 6 Free'), url('/lib/fontawesome/fa-regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
}</style><meta name="generator" content="Hexo 6.3.0"></head><body><div class="loading" style="opacity: 0"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><nav><div class="navBtn hide"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>docker</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2023-05-18T16:00:00.000Z" id="date"> 2023-05-19</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-01-10T13:25:01.798Z" id="updated"> 2024-01-10</time></div></span></div></div><hr><div id="post-content"><h1 id="docker-介绍"><a href="#docker-介绍" class="headerlink" title="docker 介绍"></a>docker 介绍</h1><p>Docker最初是DotCloud公司在法国期间发起的一个公司内部项目，后来以Apache2.0授权协议开源，代码在Github_上维护。</p>
<p>Docker是基于Google公司推出的Golang语言开发而来，基于Linpux内核的Cgroups、 NameSpace, 以及Union FS等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。</p>
<p>由于隔离的进程独立于宿主机和其他隔离的进程，也被称之为容器。</p>
<p>最初的Docker是基于LXC的，后来去除L XC转而使用自行开发的L ibcontainer。<br>Docker被定义为开源的容器引擎，可以方便的对容器进行管理。例如对镜像打包封装，引入Docker Registry对镜像统一管理。</p>
<p>利用Docker可以实现开发，测试，生产环境的部署一致性， 极大的减少运维成本。</p>
<h1 id="容器和虚拟机的差异"><a href="#容器和虚拟机的差异" class="headerlink" title="容器和虚拟机的差异"></a>容器和虚拟机的差异</h1><h2 id="传统虚拟机技术"><a href="#传统虚拟机技术" class="headerlink" title="传统虚拟机技术"></a>传统虚拟机技术</h2><p>虚拟机是虚拟出一套硬件，在其上面运行一个完整的操作系统，例如我们使用的KVM,指定镜像，然后安装系统，最终可以使用，在该系统上再运行所需的应用程序。<br>KVM创建虚拟机时，指定较少的CPU,内存，硬盘等资源，虚拟机性能较低。<br class='item-img' data-src='/pics/KVM.png'><img src="/pics/KVM.png"></p>
<h2 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h2><p>容器内的应用程序直接运行在宿主机的内核 上，窗口内没有自己的内核 ，也没有对硬件进行虚拟，因此容器比起虚拟机更为轻便<br class='item-img' data-src='/pics/container.png'><img src="/pics/container.png"></p>
<h2 id="容器对比KVM的好处"><a href="#容器对比KVM的好处" class="headerlink" title="容器对比KVM的好处"></a>容器对比KVM的好处</h2><ul>
<li>窗口能够提供宿主机的性能，而KVM虚拟机是分配宿主机硬件资源，性能较弱</li>
<li>同样配置的宿主机，最多可以启动10个虚拟机的话，可以启动100+的容器数量</li>
<li>启动一个KVM虚拟机，得有一个完整的开机流程，花费时间较长，而启动一个窗口只需要一条命令</li>
<li>KVM需要硬件CPU的虚拟化支持，而窗口不需要</li>
</ul>
<h2 id="为什么选择docker"><a href="#为什么选择docker" class="headerlink" title="为什么选择docker"></a>为什么选择docker</h2><ul>
<li>docker更高效的利用系统资源</li>
<li>更快的启动时间</li>
<li>一致性的环境</li>
<li>持续交付和部署</li>
<li>更轻松的迁移</li>
<li>利用docker的镜像，部署迁移项目，还可以跨系统平台</li>
</ul>
<h2 id="docker能做什么"><a href="#docker能做什么" class="headerlink" title="docker能做什么"></a>docker能做什么</h2><ul>
<li>可以把应用程序代码及运行依赖环境打包成镜像，作为交付介质，在各环境部署</li>
<li>可以将镜像(image)启动成容器(container)，并且提供多容器的生命周期进行管理(启，停，删)</li>
<li>container容器之间相互隔离，且每个窗口可以设置资源限额</li>
<li>提供轻量级虚拟化功能，容器就是宿主机中一个个的虚拟的空间，彼此相互隔离，完全独立</li>
</ul>
<h1 id="docker安装部署"><a href="#docker安装部署" class="headerlink" title="docker安装部署"></a>docker安装部署</h1><h2 id="docker最核心的组件"><a href="#docker最核心的组件" class="headerlink" title="docker最核心的组件"></a>docker最核心的组件</h2><ul>
<li>image镜像，构建容器(我们将应用程序运行所需的环境，打包为镜像文件)</li>
<li>Container,容器(你的应用程序，就跑在容器中)</li>
<li>镜像仓库(dockerhub)(保存镜像文件，提供上传，下载镜像)作用好比github</li>
<li>Dockerfile,将你部署项目的操作，写成一个部署脚本，这就是dockerfile,且该脚本还能够构建镜像文件</li>
</ul>
<h2 id="Docker引擎"><a href="#Docker引擎" class="headerlink" title="Docker引擎"></a>Docker引擎</h2><p class='item-img' data-src='/pics/docker_compose.png'><img src="/pics/docker_compose.png"></p>
<h2 id="Docker-Daemon"><a href="#Docker-Daemon" class="headerlink" title="Docker Daemon"></a>Docker Daemon</h2><p>安装使用Docker,得先运行Docker Daemon进程，用于管理docker,如：</p>
<ul>
<li>镜像 images</li>
<li>容器 containers</li>
<li>网络 network</li>
<li>数据卷 Data Volumes</li>
</ul>
<h2 id="Rest接口"><a href="#Rest接口" class="headerlink" title="Rest接口"></a>Rest接口</h2><p>提供和Daemon交互的API接口</p>
<h2 id="Docker-Client"><a href="#Docker-Client" class="headerlink" title="Docker Client"></a>Docker Client</h2><p>客户端使用REST API和Docker Daemon进行访问</p>
<h2 id="Docker平台组成"><a href="#Docker平台组成" class="headerlink" title="Docker平台组成"></a>Docker平台组成</h2><p class='item-img' data-src='/pics/docker_compose2.png'><img src="/pics/docker_compose2.png"></p>
<h2 id="Images"><a href="#Images" class="headerlink" title="Images"></a>Images</h2><p>镜像是一个只读模板，用于创建窗口，也可以通过Dockerfile文本描述镜像的内容<br>镜像的概念类似于编程开发里面向对象的类，从一个基类开始(基础镜像Base Image)<br>构建窗口的过程，就是运行镜像，生成容器的实例<br>Docker镜像的描述文件是Dockerfile,包含了如下的指令</p>
<ul>
<li>FROM 定义了基础镜像</li>
<li>MAINTAINER 作者</li>
<li>RUN 运行Linux命令</li>
<li>ADD 添加文件&#x2F;目录</li>
<li>ENV 环境变量</li>
<li>CMD 运行进程</li>
</ul>
<h2 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h2><p>容器是一个镜像的运行实例，镜像&gt;容器<br>创建容器的过程</p>
<ul>
<li>获取镜像，如 <code>docker pull contos</code>,从镜像仓库拉取</li>
<li>使用镜像创建容器</li>
<li>分配文件系统，挂载一个读写层，在读写层加载镜像</li>
<li>分配网络&#x2F;网桥接口，创建一个网络接口，让容器和宿主机通信</li>
<li>容器获取IP地址</li>
<li>执行容器命令，如&#x2F;bin&#x2F;bash</li>
<li>反馈容器启动结果</li>
</ul>
<h2 id="Registry"><a href="#Registry" class="headerlink" title="Registry"></a>Registry</h2><p>Docker镜像需要进行管理，docker提供了Registry仓库，其实它也是一个容器。可以基于该容器运行私有仓库。<br>也可以使用Docker Hub互联网公有镜像仓库</p>
<h1 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h1><p>Docker引擎主要有两个版本：企业版(EE)和社区版(CE)</p>
<h2 id="安装环境初始化"><a href="#安装环境初始化" class="headerlink" title="安装环境初始化"></a>安装环境初始化</h2><p class='item-img' data-src='/pics/docker_ins_init.png'><img src="/pics/docker_ins_init.png"></p>
<p>机器环境初始化</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 1.防火墙</span><br><span class="hljs-comment"># 2.yumidr</span><br><span class="hljs-comment"># 3.安装基础软件</span><br><br>wget -O /etc/yum.repos.d/CentOS-Base.repo http:<span class="hljs-regexp">//mirr</span>ors.aliyun.com/repo/Centos-<span class="hljs-number">7</span>.repo<br>wget -O /etc/yum.repos.d/epel.repo https:<span class="hljs-regexp">//mirr</span>ors.aliyun.com/repo/epel-<span class="hljs-number">7</span>.repo<br><br>yum clean all<br>yum makecache<br><br>iptgables -F <span class="hljs-comment">#清空系统规则</span><br>getenforce <span class="hljs-comment">#确保selinux也是处于禁用状态</span><br><br><br>yum install -<span class="hljs-keyword">y</span> bash-completion vim lrzsz wget expect net-tools nc nmap tree dos2unix htop iftop iotop unzip telnet sl psmisc nethogs glances bc ntpdate openldap-devel<br><br></code></pre></td></tr></table></figure>

<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#docker必须安装在centos7平台，内核版本不低于3.10</span><br><span class="hljs-comment">#在centos平台运行docker可能会遇见些警告信息，修改内核配置参数，打开内核转发功能</span><br><br>uname -r<br></code></pre></td></tr></table></figure>

<p>开启Linux内核的流量转发</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/sysctl.d/docker.conf</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">net.ipv4.conf.default.rp_filter = 0</span><br><span class="hljs-string">net.ipv4.conf.all.rp_filter = 0</span><br><span class="hljs-string">net.ipv4.ip_forward = 1</span><br><span class="hljs-string">EOF</span><br><br>modprobe br_netfilter<br><br><span class="hljs-comment"># 加载修改内核的参数配置文件</span><br>sysctl -p /etc/sysctl.d/docker.conf<br></code></pre></td></tr></table></figure>

<p>利用yum快速安装docker</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 提前配置好yum仓库</span><br><span class="hljs-comment"># 1.阿里云自带仓库 2.阿里云提供的docker专属repo仓库</span><br>curl -o /etc/yum.repos.d/Centos-<span class="hljs-number">7</span>.repo http:<span class="hljs-regexp">//mirr</span>ors.aliyun.com/repo/Centos-<span class="hljs-number">7</span>.repo<br>curl -o /etc/yum.repos.d/docker-ce.repo http:<span class="hljs-regexp">//mirr</span>ors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><br><span class="hljs-comment"># 更新yum缓存</span><br>yum clean all &amp;&amp; yum makecache <br><br><span class="hljs-comment"># 可以直接yum安装docker了</span><br>yum install docker-ce-<span class="hljs-number">20.10</span>.<span class="hljs-number">6</span> -<span class="hljs-keyword">y</span><br><span class="hljs-comment"># 查看源中可用版本</span><br>yum list docker-ce --showduplicates | <span class="hljs-keyword">sort</span> -r<br><span class="hljs-comment"># 如果需要安装旧版本</span><br>yum install -<span class="hljs-keyword">y</span> docker-ce-<span class="hljs-number">18.09</span>.<span class="hljs-number">9</span><br><br><span class="hljs-comment"># 如果要卸载</span><br>yum remove -<span class="hljs-keyword">y</span> docker-xxx<br><br></code></pre></td></tr></table></figure>

<h2 id="镜像加速器"><a href="#镜像加速器" class="headerlink" title="镜像加速器"></a>镜像加速器</h2><p>使用docker首要操作就是获取镜像文件，默认下载是从Docker Hub下载，网速较慢，国内很多云服务商都提供了加速器服务，阿里云加速器，Daocloud加速器，灵雀云加速器</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 1.修改docker配置文件，我们选用七牛云镜像站</span><br>cat /etc/docker/daemon.json<br><br><span class="hljs-comment"># 也可以配置加速源</span><br>https:<span class="hljs-regexp">//</span>cr.console.aliyun.com/cn-hangzhou/instances/mirrors<br><span class="hljs-keyword">mkdir</span> -p /etc/docker<br>vi /etc/docker/daemon.json<br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span> : [<br>    <span class="hljs-string">&quot;https://8xpk5wnt.mirror.aliyuncs.com&quot;</span><br>  ]<br>&#125;<br><br><span class="hljs-comment"># 2.重启，设置开机自启</span><br>systemctl daemon-reload<br>systemctl enable docker<br>systemctl restart docker<br><br>ps -ef | <span class="hljs-keyword">grep</span> docker<br><br>docker ps<br>docker images == docker image ls <br>docker version <br><span class="hljs-comment"># 看到Client和Server说明docker正确安装和启动成功了</span><br></code></pre></td></tr></table></figure>

<h2 id="启动第一个docker容器"><a href="#启动第一个docker容器" class="headerlink" title="启动第一个docker容器"></a>启动第一个docker容器</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 先搜索镜像文件是否存在</span><br>docker search nginx<br><span class="hljs-comment"># 1.获取镜像，获取是从之前配置好的docker镜像站中，去拉取镜像</span><br>docker pull nginx[:tag]<br><span class="hljs-comment"># 2.运行镜像，生成容器,运行nginx镜像，运行出，具体的容器，容器中就跑着一个nginx服务了</span><br>docker run 参数 镜像的名字/id<br><br><span class="hljs-comment"># -d 后台运行容器</span><br><span class="hljs-comment"># -p 80:80 端口映射 宿主机端口:容器端口  访问宿主机的这个端口，也就访问了容器内的端口</span><br>netstat -tunlp<br>docker run -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> nginx <span class="hljs-comment"># 会返回一个容器的id</span><br><br><span class="hljs-comment"># 查看容器是否在运行</span><br>docker ps<br><span class="hljs-comment"># 此时可以访问宿主机的80端口，就访问到了容器内的80端口</span><br><span class="hljs-comment"># 停止容器，查看结果</span><br>docker ps <br>docker stop 容器id<br><span class="hljs-comment"># 开始运行</span><br>docker start 容器id<br><br><span class="hljs-comment"># 查看本地的docker镜像有哪些</span><br>docker images<br><span class="hljs-comment"># 删除镜像</span><br>docker rmi 镜像id<br><br></code></pre></td></tr></table></figure>

<h1 id="docker的生命周期"><a href="#docker的生命周期" class="headerlink" title="docker的生命周期"></a>docker的生命周期</h1><p>学习docker的核心要素，就是要搞明白镜像image,容器!<br class='item-img' data-src='/pics/docker3.png'><img src="/pics/docker3.png"></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker build . <span class="hljs-comment"># 构建dockerfile生成镜像</span><br>docker save 导出镜像<br>docker load 导入镜像<br><span class="hljs-comment"># 公司同事之间传递镜像文件，把镜像导出为一个压缩文件</span><br>docker run 镜像 <span class="hljs-comment"># 生成一个容器</span><br>docker stop 容器id/名字<br>docker start 容器id/名字<br>docker restart 容器id/名字<br><br><span class="hljs-comment">#当你在容器中，定制安装了些软件，想要提交该容器生成一个镜像</span><br>docker commit 容器id<br><br><span class="hljs-comment"># 1.获取了一个centos镜像，连vim都没有</span><br><span class="hljs-comment"># 2.docker run centos,可以进入容器</span><br><span class="hljs-comment"># 3.在容器中安装了一个vim</span><br><span class="hljs-comment"># 4.docker commit 容器id</span><br><span class="hljs-comment"># 5.提交后生成的镜像就是携带vim的镜像了</span><br></code></pre></td></tr></table></figure>

<h1 id="docker镜像的原理"><a href="#docker镜像的原理" class="headerlink" title="docker镜像的原理"></a>docker镜像的原理</h1><p>我们在获取redis镜像的时候，发现是下载了多行信息，最终获取了一个完整的镜像文件</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker pull redis<br><span class="hljs-comment"># 会下载很多层</span><br>docker images<br><br></code></pre></td></tr></table></figure>
<p>使用vmware虚拟机安装的系统，是一个完整的系统，包括2部分</p>
<ul>
<li>Linux内核，作用是提供操作系统的基本功能，和机器硬件交互</li>
<li>centos7发行版，作用是提供软件功能，例如yum安装包等</li>
</ul>
<p>因此，Linux内核+centos发行版，就组成了一个系统<br>是否有一个办法，可以灵活的替换发行版，让我们使用不同的系统</p>
<p><strong>docker就实现了这个功能，技术手段就是docker images</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 查看发行版</span><br>cat /etc/os-release<br><span class="hljs-comment"># 查看内核版本</span><br>uname -r<br><br><span class="hljs-comment"># 利用docker获取不同的发行版镜像</span><br>docker pull centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br>docker pull ubuntu<br><br><span class="hljs-comment"># 运行容器且进入容器内</span><br><span class="hljs-comment"># -i 交互式操作 -t 开启一个终端 bash 进入容器后执行的命令</span><br>docker run -it centos bash<br>cat /etc/redhat-release<br><span class="hljs-keyword">exit</span><br><br>docker run -it ubuntu sh<br>cat /etc/lsb-release<br><span class="hljs-keyword">exit</span><br><br>docker search suse<br>docker search opensuse<br>docker pull opensuse<br>docker images<br>docker run -it opensuse bash<br>cat /etc/SuSE-release<br>hostname <span class="hljs-comment"># 返回的是容器id</span><br><span class="hljs-keyword">exit</span><br><br></code></pre></td></tr></table></figure>
<p>小节</p>
<ol>
<li>一个完整的系统，是由Linux内核+发行版，才组成了一个可以使用的完整系统</li>
<li>利用docker容器，可以获取不同的发行版镜像，然后基于该镜像，运行出各种发行版去使用</li>
</ol>
<p><strong>docker的好处</strong></p>
<ul>
<li>解决了环境的兼容问题，在容器中运行Linux发行版，以及各种软件，[windows+docker+容器1(centos)+容器2(ubuntu)]</li>
<li>环境很干净，安装的所有内容，都在容器里，不想要了，直接删除容器，不影响宿主机</li>
<li>比如想把mysql容器内的数据，配置，全部迁移到服务器上，只需要提交该容器，生成镜像，镜像放到服务器上，docker run 就可以了。</li>
</ul>
<p class='item-img' data-src='/pics/docker_images_theory.png'><img src="/pics/docker_images_theory.png"></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs perl">Union File System<br>docker通过联合文件系统，将上述的不同的每一层，整合为一个文件系统，为用户隐藏了多层的视角。<br>当通过一个image启动容器时，docker会在该image最顶层，添加一个读写文件系统作为容器，然后运行该容器<br>docker镜像本质是基于UnionFS管理的分层文件系统<br>dockerfile的作用：自定义docker镜像的每一层作用<br></code></pre></td></tr></table></figure>

<h2 id="docker镜像定义"><a href="#docker镜像定义" class="headerlink" title="docker镜像定义"></a>docker镜像定义</h2><p>我们如果自定义镜像，docker镜像不包含Linux内核，和宿主机共用。<br>我们想要定义一个mysql5.6镜像，我们会这么做</p>
<ul>
<li>获取基础镜像，选择一个发行版平台(ubuntu,centos)</li>
<li>在centos镜像中安装mysql5.6软件</li>
</ul>
<p>导出镜像，可以命名为mysql:5.6镜像文件。<br>从这个过程，我们可以感觉出这是一层一层添加的，docker镜像的层级概念就出来了，底层是centos镜像，上层是mysql镜像，centos镜像层属于父镜像。<br class='item-img' data-src='/pics/docker_layer.png'><img src="/pics/docker_layer.png"></p>
<p>Docker镜像是在基础镜像之后，安装软件，配置软件，添加新的层，构建出来。<br>dockerfile构建时，更加清晰。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 查看正在运行的容器</span><br>docker ps<br><span class="hljs-comment"># 进入到正在运行的容器内</span><br>docker <span class="hljs-keyword">exec</span> -it 容器id bash<br></code></pre></td></tr></table></figure>

<h2 id="docker镜像为什么分层"><a href="#docker镜像为什么分层" class="headerlink" title="docker镜像为什么分层"></a>docker镜像为什么分层</h2><p>镜像分层的一大好处就是共享资源，例如有多个镜像都来自于同一个base镜像，那么在docker host只需要存储一份bash镜像。</p>
<p>内存里也只需要加载一份host,即可为多个容器服务。</p>
<p>即使多个容器共享一个base镜像，某个容器修改了base镜像的内容，如修改&#x2F;etc&#x2F;下配置文件，其他容器的&#x2F;etc&#x2F;下的内容是不会被修改的，修改动作只限制在单个容器内，这就是容器的写入时复制特性(Copy-on-write)</p>
<h2 id="可写的容器层"><a href="#可写的容器层" class="headerlink" title="可写的容器层"></a>可写的容器层</h2><p>当容器启动后，一个新的可写层被加载到镜像的顶部，这一层通常被称为容器层，容器层下的都称为镜像层<br class='item-img' data-src='/pics/image_layer.png'><img src="/pics/image_layer.png"></p>
<p>对所有容器的修改操作，都只会发生在容器层里，只有容器层是可写的，其余镜像层都是只读的。</p>
<ul>
<li>添加文件  容器中创建文件时，新文件被添加到容器层中。</li>
<li>读取文件  在容器中读取某个文件时，Docker会从上往下依次在各镜像中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存</li>
<li>修改文件  在容器中修改已存在的文件时，Docker会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后改之。</li>
<li>删除文件  在容器中删除文件时，Docker会从上往下依次在各镜像层中查找此文件。找到后，会在容器层中<strong>记录下此删除操作</strong>(只是记录删除操作)</li>
</ul>
<p>只有当需要修改时才复制一份数据，这种特性被称作Copy-on-Write.可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p>
<p><strong>容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享</strong></p>
<h2 id="Docker镜像的内容"><a href="#Docker镜像的内容" class="headerlink" title="Docker镜像的内容"></a>Docker镜像的内容</h2><p>docker镜像层级管理的方式大大便捷了Docker镜像的分发和在存储。Docker hub是为全世界的镜像仓库。</p>
<ul>
<li>Docker镜像代表一个容器的文件系统内容</li>
<li>镜像层级技术属于联合文件系统</li>
<li>容器是一个动态的环境，每一层镜像里的文件都属于静态内容<ul>
<li>dockerfile里的ENV,VOLUME,CMD等内容都会落实到容器环境里</li>
</ul>
</li>
</ul>
<h2 id="docker镜像的实际使用学习"><a href="#docker镜像的实际使用学习" class="headerlink" title="docker镜像的实际使用学习"></a>docker镜像的实际使用学习</h2><p>1.下载安装docker工具<br>2.获取该软件的docker镜像，下载nginx镜像，<code>docker pull nginx</code><br>3.运行该镜像，启动了容器，这个nginx就运行在容器中<br>4.停止容器，删除镜像，就好像没有安装过nginx一样<br>就好比沙箱一样的环境<br>基于镜像的增删改查</p>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 1.获取镜像，镜像托管仓库，就好比yum源一样</span><br><span class="hljs-comment"># 默认的docker仓库是，dockerhub,有大量的优质镜像，以及用户上传的镜像，centos容器安装vim nginx ...提交镜像，上传到dockerhub</span><br><br>docker search 镜像名:tag tag就是具体的标签版本<br>docker version <br>docker ps<br>docker images == docker image ls<br><br>docker search centos<br>docker pull centos<br>docker images<br><span class="hljs-comment"># 下载镜像文件</span><br>docker pull centos <span class="hljs-comment"># 默认是centos:latest</span><br>docker pull centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br><span class="hljs-comment"># 查看docker数据的存放目录</span><br>docker info [ | <span class="hljs-keyword">grep</span> Root]<br>ls /var/lib/docker<br><br>docker images<br>ls /var/lib/docker/image/overlay2/imagedb/content/sha256<br><span class="hljs-comment"># 这里面的id是和docker images查看出来的id是一样的</span><br><span class="hljs-comment"># 查看id，内容是json格式的数据</span><br><span class="hljs-comment"># 作用是记录 镜像 和容器的配置关系</span><br><br><span class="hljs-comment"># 使用不同的镜像生成容器</span><br><span class="hljs-comment"># -it 开启一个交互式的终端，--rm 容器退出时删除该容器</span><br>docker run -it --rm centos bash<br><span class="hljs-keyword">exit</span><br><br>docker images<br>docker run -it --rm centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> bash<br><br></code></pre></td></tr></table></figure>

<h2 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker images <br><br><span class="hljs-comment">## 查看具体的镜像</span><br>docker images centos<br>docker images ubuntu<br><br><span class="hljs-comment"># 可以指定具体的tag</span><br>docker images centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br><br><span class="hljs-comment"># 只列出镜像的id</span><br><span class="hljs-comment"># -q --quiet 只列出id</span><br>docker images -<span class="hljs-keyword">q</span> <br><br><span class="hljs-comment"># 格式化显示镜像 这里docker 的模板语言 --format</span><br>docker images --<span class="hljs-keyword">format</span> <span class="hljs-string">&quot;&#123;&#123;.ID&#125;&#125;--&#123;&#123;.Repository&#125;&#125;&quot;</span><br><span class="hljs-comment"># 以表格形式显示，美化</span><br>docker images --<span class="hljs-keyword">format</span> <span class="hljs-string">&quot;table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 搜索dockerhub的镜像</span><br>docker search 镜像名<br></code></pre></td></tr></table></figure>

<h2 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 镜像加速</span><br>curl -sSL https:<span class="hljs-regexp">//g</span>et.daocloud.io/daotools/set_mirror.sh | sh -s http:<span class="hljs-regexp">//</span>f1361db2.m.daocloud.io<br>docker version &gt;=<span class="hljs-number">1.12</span><br>&#123;<span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;http://f1361db2.m.daocloud.io&quot;</span>]&#125;<br>Success.<br>You need to restart docker to take effect: sudo systemctl restart docker<br><br>sudo systemctl restart docker<br><span class="hljs-comment"># 下载</span><br>docker pull hello-world<br>docker images<br>docker run hello-world<br><br><span class="hljs-comment"># 根据镜像的id,名字，摘要等 </span><br>docker images hello-world<br><span class="hljs-comment"># 被删除的镜像不得有依赖容器的记录</span><br>docker rmi hello-world<br>docker ps -a <br><br><span class="hljs-comment"># 删除容器记录</span><br>docker rm 容器id<br><br><span class="hljs-comment"># 指定id的前三位即可</span><br>docker rmi d11<br><br></code></pre></td></tr></table></figure>

<h2 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker images<br><span class="hljs-comment"># 列出所有的镜像</span><br>docker images -a<br><span class="hljs-comment"># 列出所有的镜像id </span><br>docker images -aq<br><br>echo <span class="hljs-string">`docker images -aq`</span><br><span class="hljs-comment"># 指删除镜像，慎用</span><br>docker rmi <span class="hljs-string">`docker images -aq`</span><br>docker rm <span class="hljs-string">`docker ps -aq`</span><br><br><span class="hljs-comment"># 导出镜像</span><br>docker run -it centos bash<br><span class="hljs-comment"># 比如默认运行的centos镜像，不提供vim功能，运行该容器后，在容器内安装vim</span><br>yum install -<span class="hljs-keyword">y</span> vim <br><span class="hljs-comment"># 然后提交该镜像，再导出该镜像为压缩文件，可以发给其他人用</span><br><span class="hljs-keyword">exit</span><br>docker ps -a<br><br><span class="hljs-comment"># 导出镜像的命令</span><br>docker images<br>docker image save centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> &gt; <span class="hljs-regexp">/opt/</span>centos7.<span class="hljs-number">8.2003</span>.tgz<br><br><span class="hljs-comment"># 导入镜像的命令</span><br>docker image load -i /opt/centos7.<span class="hljs-number">8.2003</span><br><br><span class="hljs-comment"># 查看镜像详细信息</span><br>docker info <span class="hljs-comment">#看的是docker 进程的信息</span><br>docker image inspect 镜像id<br></code></pre></td></tr></table></figure>

<h1 id="dock容器"><a href="#dock容器" class="headerlink" title="dock容器"></a>dock容器</h1><p><code>docker run</code> 等于创建+启动<br>docker run 镜像名，如果镜像不存在本地，则会在线去下载该镜像</p>
<p><strong>注意：容器内的进程必须处于前台运行状态，否则容器就会退出</strong>，自己部署一个容器运行，命令不得后台运行，前台运行即可<br>如果容器内，什么事也没做，容器也会挂掉，容器内必须有一个进程在前台运行<br>我们运行nginx基础镜像，没有运行任何程序，因此容器直接挂掉</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs perl">nohub ping baidu.com &amp;<br>jobs <span class="hljs-comment"># 查看后台运行的程序</span><br>fg <span class="hljs-number">1</span> <span class="hljs-comment"># 把后台运行的程序提到前台</span><br><br><span class="hljs-comment"># 运行容器的玩法</span><br><span class="hljs-comment"># 1.运行一个挂掉的容器</span><br>docker run centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br><span class="hljs-comment"># 这个写法，会产生多条独立的容器记录，且容器内没有程序在跑，因此挂了</span><br><br><span class="hljs-comment"># 2.运行容器，且进入容器内，且在容器内执行某个命令</span><br>docker run -it centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> sh<br><br><span class="hljs-comment"># 3.开启一个容器，让它帮你运行某个程序，属于前台运行，会卡住一个终端</span><br>docker run centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> ping baidu.com<br><br><span class="hljs-comment"># 4.运行一个活着的容器，docker ps可以看到的容器</span><br><span class="hljs-comment"># -d参数，让容器在后台跑着（针对宿主机而言）</span><br>docker run -d centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> ping baidu.com<br>docker ps <span class="hljs-comment">#可以看到</span><br><br><span class="hljs-comment"># 5.丰富docker运行的参数</span><br><span class="hljs-comment"># -d 后台运行</span><br><span class="hljs-comment"># --rm 容器挂掉后自动被删除</span><br><span class="hljs-comment"># --name 给容器起个名字</span><br>docker run -d --rm centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> ping baidu.com<br>docker ps<br><br>docker run -d --rm --name baidu centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> ping baidu.com<br>docker ps<br><br>docker stop 容器id<br>docker ps -a 也看不到，因为被删除了<br><br><span class="hljs-comment"># 6.查看容器的日志</span><br><span class="hljs-comment"># -f 动态跟踪</span><br>docker logs -f  容器id<br><br><span class="hljs-comment"># 7.进入正在运行的容器空间内</span><br>docker <span class="hljs-keyword">exec</span> -it 容器id bash <br><br><span class="hljs-comment"># 8.查看容器的详细信息</span><br>docker container inspect 容器id <span class="hljs-comment"># 返回的是json数据串</span><br><br><span class="hljs-comment"># 9.容器的端口映射</span><br>docker run -it nginx <br>netstat -tunlp | <span class="hljs-keyword">grep</span> <span class="hljs-number">80</span> <span class="hljs-comment"># 此时是不能访问到容器内的nginx的</span><br><br><span class="hljs-comment">#后台运行nginx容器，起个名字，且端口映射宿主机的85端口，访问到容器内的80端口</span><br>docker run -d --name my_nginx -p <span class="hljs-number">85</span>:<span class="hljs-number">80</span> nginx<br>docker ps<br><br><span class="hljs-comment"># 随机端口映射 -P 随机访问一个宿主机的空闲端口，映射到容器内打开的端口</span><br>docker run -d --name my_nginx_random -P nginx <br><br><span class="hljs-comment"># 10.容器的提交</span><br><span class="hljs-comment"># 运行基础的centos:7.8.2003 ，在容器内安装vim，然后提交新的镜像</span><br><span class="hljs-comment"># 新的镜像，再运行出的容器，默认就带有vim了</span><br>docker run -it centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span> bash<br><span class="hljs-comment"># 提交容器</span><br>docker commit 容器记录的id 自定义的镜像名<br>docker images <span class="hljs-comment"># 就可以查看到</span><br><span class="hljs-comment"># 再运行新的镜像，就带有vim</span><br></code></pre></td></tr></table></figure>

<h1 id="DockerFile镜像定制"><a href="#DockerFile镜像定制" class="headerlink" title="DockerFile镜像定制"></a>DockerFile镜像定制</h1><p>定制docker镜像的方式有两种</p>
<ul>
<li>手动修改容器内容，导出新的镜像</li>
<li>基于Dockerfile自行编写指令，基于指令流程创建镜像</li>
</ul>
<h2 id="Dockerfile简介"><a href="#Dockerfile简介" class="headerlink" title="Dockerfile简介"></a>Dockerfile简介</h2><p>镜像是多层存储，每一层在前一层的基础上进行修改<br>容器也是多层存储，以镜像为基础层，在其基础上加一层作为容器运行时的存储层。</p>
<ul>
<li>手动修改容器内容，然后docker commit 提交容器为新的镜像</li>
<li>通过在dockerfile中定义一系列的命令和参数构成的脚本，然后这些命令应用于基础镜像层，依次添加层，最终生成一个新的镜像。极大简化了部署工作</li>
</ul>
<p>官方提供的dockerfile实例<br><code>https://github.com/CentOS/CentOS-Dockerfiles</code></p>
<p><strong>dockerfile的主要组成部分：</strong></p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">基础镜像信息 FROM centos:<span class="hljs-number">6.8</span><br>制作镜像操作指令RUN yum install openssh-server -<span class="hljs-keyword">y</span><br>容器启动时执行指令 CMD [<span class="hljs-string">&quot;/bin/bash&quot;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="dockerfile-指令"><a href="#dockerfile-指令" class="headerlink" title="dockerfile 指令"></a>dockerfile 指令</h2><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">FROM 指定基础镜像<br>MAINTAINER 指定维护者信息，可以没有<br>RUN 你想让它做什么（在命令前面加上RUN即可）<br>ADD 添加宿主机的文件到容器内，还多了一个自动解压的功能<br><span class="hljs-comment"># RUN tar -zxf /opt/xxx.tgz # 报错！该tgz文件不存在！</span><br>COPY 添加宿主机的文件到容器内，仅仅拷贝<br>WORKDIR 设置当前工作目录<br>VOLUME 设置卷，挂载主机目录<br>EXPOSE 指定对外的端口<br>CMD 指定容器启动后要做的事<br></code></pre></td></tr></table></figure>
<p>docker其他指令：</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">COPY 复制文件<br>ENV 环境变量<br>ENTRYPOINT 容器启动后执行的命令<br></code></pre></td></tr></table></figure>

<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 1.创建Dockerfile，注意文件名必须是这个</span><br>vim Dockerfile<br><br>FROM nginx<br>RUN echo <span class="hljs-string">&#x27;nginx首页&#x27;</span> &gt; <span class="hljs-regexp">/usr/s</span>hare/nginx/html/index.html<br><br><span class="hljs-comment"># 2.构建dockerfile,在Dockerfile文件相同的文件夹</span><br>docker build .<br><span class="hljs-comment"># 3.修改镜像名</span><br>docker tag 镜像id 名字<br><span class="hljs-comment"># 4.运行该镜像</span><br>netstat -tunlp<br>docker images<br>docker ps<br>docker run -d -p <span class="hljs-number">80</span>:<span class="hljs-number">80</span> <span class="hljs-keyword">my</span>-nginx<br><br><span class="hljs-comment"># 5.查看宿主机的80端口</span><br>ip:<span class="hljs-number">80</span><br></code></pre></td></tr></table></figure>

<h3 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># copy指令从宿主机复制文件到/目录到新的一层镜像内</span><br>copy xxx.py /home/<br><br><span class="hljs-comment"># 支持多个文件，以及通配符形式复制，语法要满足Golang的filepath.Match</span><br>copy xxx* <span class="hljs-regexp">/tmp/</span>cc?.txt /home/<br><span class="hljs-comment"># COPY指令能够保留源文件的元数据，如权限，访问时间等</span><br></code></pre></td></tr></table></figure>

<h3 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl">特性和COPY一致，不过多了些功能<br><span class="hljs-number">1</span>.源文件是一个URL,此时docker引擎会下载该链接，放入目标路径，且权限自动设为<span class="hljs-number">600</span>,若这不是期望的结果，还要增加一层RUN指令进行调整<br><span class="hljs-number">2</span>.源文件是一个URL,且是一个压缩包，不会自动解压，需要单独用RUN命令解压<br><span class="hljs-number">3</span>.源文件是一个压缩文件，且是gzip,bzip2,xz,tar情况，ADD指令会自动解压缩该文件到目标路径<br></code></pre></td></tr></table></figure>
<p>Dockerfile官方更推荐用COPY,ADD包含了更多复杂的功能，且ADD会使构建缓存失效，导致镜像构建缓慢</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs perl">用法，注意是双引号<br>CMD [<span class="hljs-string">&quot;参数1&quot;</span>,<span class="hljs-string">&quot;参数2&quot;</span>]<br>在指定了entrypoint指令后，用CMD指定具体参数<br><br>docker不是虚拟机，容器就是一个进程，既然是进程，那么程序在启动的时候需要指定些运行参数，这就是CMD指令的作用<br><br><span class="hljs-comment"># 该镜像在运行容器实例的时候，执行的具体参数是什么</span><br>例如centos镜像默认的CMD是/bin/bash，直接docker run -it centos 会直接进入bash解释器。<br>也可以启动容器的时候，指定参数。docker run -it centos cat /etc/os-releasea<br><br>CMD运行shell命令，也会被转化为shell形式<br>例如<br>CMD echo $PATH<br>会被转化为<br>CMD [<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;echo $PATH&quot;</span>]<br></code></pre></td></tr></table></figure>

<h2 id="容器内运行程序"><a href="#容器内运行程序" class="headerlink" title="容器内运行程序"></a>容器内运行程序</h2><p>这里要注意的是，docker不是虚拟机的概念，虚拟机里的程序运行，基本上都是在后台运行，利用systemctl运行，但是容器内没有后台进程的概念，必须在前台运行<br>容器就是为了主进程而存在的，主进程如果退出了，容器也就失去了意义，自动退出<br>例如有一个经典的问题</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">CMD systemctl start nginx<br>这样的写法是错误的，容器会产即退出<br>因为systemctl start nginx 是希望以守护进程形式启动nginx,且CMD命令也会转化为<br>CMD [<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;systemctl start nginx&quot;</span>]<br>这样的命令主进程是sh解释器，执行完毕后产即结束了，因此容器也就退出了<br>正确的做法应该是CMD [<span class="hljs-string">&quot;nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]<br></code></pre></td></tr></table></figure>

<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>和RUN指令一样，分为两种格式</p>
<ul>
<li>exec</li>
<li>shell</li>
</ul>
<p>作用和CMD一样，都是在指定容器启动程序以及参数<br>当指定了ENTRYPOINT之后，CMD指令的语义就有了变化，而是把CMD的内容当作参数传递给ENTRYPOINT指令</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># 实际用法</span><br><span class="hljs-comment"># 1.准备好dockerfill</span><br>vim Dockerfile<br>FROM centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br>RUN rpm --rebuilddb &amp;&amp; yum install epel-release -<span class="hljs-keyword">y</span><br>RUN rpm --rebuilddb &amp;&amp; yum install curl -<span class="hljs-keyword">y</span><br>CMD [<span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;http://ipinfo.io/ip&quot;</span>]<br><span class="hljs-comment"># 2.构建镜像</span><br>docker build .<br><span class="hljs-comment"># 3.查看结果</span><br>Successfully build 镜像id<br><span class="hljs-comment"># 4.检查镜像</span><br>docker tag 镜像id centos_curl<br>docker images <br><span class="hljs-comment"># 5.运行镜像，生成容器 生成的只是容器记录</span><br>docker run centos_curl<br><span class="hljs-comment"># 6.上述运行正确，但是想再传入一个参数，发现是无法传入参数的,该形式是覆盖镜像中cmd</span><br>docker run centos_curl -I<br><span class="hljs-comment"># 报错</span><br>docker run centos_curl pwd<br>/<br><span class="hljs-comment"># 7.想要正确的给容器传入一个-I参数,希望容器内能正确完整的执行下面命令</span><br>curl -s http:<span class="hljs-regexp">//ipin</span>fo.io/io -I<br><span class="hljs-comment"># 8.解决办法</span><br>给容器传入新的，完整的命令<br>docker run centos_curl curl -s http:<span class="hljs-regexp">//ipin</span>fo.io/io -I<br>可以正确运行，但是没有意义<br><span class="hljs-comment"># 9.正确的做法应该是使用ENTRYPOINT</span><br>修改Dockerfile,如下<br>vim Dockerfile<br>FROM centos:<span class="hljs-number">7.8</span>.<span class="hljs-number">2003</span><br>RUN rpm --rebuilddb &amp;&amp; yum install epel-release -<span class="hljs-keyword">y</span><br>RUN rpm --rebuilddb &amp;&amp; yum install curl -<span class="hljs-keyword">y</span><br>ENTRYPOINT [<span class="hljs-string">&quot;curl&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;http://ipinfo.io/ip&quot;</span>]<br><span class="hljs-comment"># 10.重新构建Dockerfile</span><br>docker build .<br><span class="hljs-comment"># 11.重新运行镜像，看结果，以及传入新的参数</span><br><span class="hljs-comment"># 此时发现，传入的CMD指令，当做了ENTRYPOINT的参数，容器内执行的完整命令是curl -s http://ipinfo.io/ip -I</span><br>docker run centos_crul_new -I<br></code></pre></td></tr></table></figure>

<h3 id="ARG和ENV指令"><a href="#ARG和ENV指令" class="headerlink" title="ARG和ENV指令"></a>ARG和ENV指令</h3><p>设置环境变量</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs perl">Dockerfile脚本，shell脚本<br>ENV NAME=<span class="hljs-string">&quot;name&quot;</span><br>ENV AGE=<span class="hljs-string">&quot;19&quot;</span><br>ENV MYSQL_VERSION=<span class="hljs-number">5.6</span><br>后续所有操作，通过$NAME 就可以直接获取变量了，维护Dockerfile脚本时更友好，方便<br><br>ARG和ENV一样 设置环境变量 <br>区别在于ENV无论是在镜像构建时，还是在容器运行时，该变量都可以使用<br>ARG只是用于构建镜像需要设置的变量，容器运行时就消失了<br></code></pre></td></tr></table></figure>

<h3 id="VOLUE"><a href="#VOLUE" class="headerlink" title="VOLUE"></a>VOLUE</h3><p>容器在运行时，应该保证在存储层不写入任何数据，运行在容器内产生的数据，我们推荐是挂载，写入到宿主机上，进行维护</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs perl">VOLUME /data <span class="hljs-comment"># 将容器内的/data文件夹，在容器运行时该目录自动挂载为匿名卷，任何向该目录中写入数据的操作，都不会被容器记录，保证容器存储层的无状态理念</span><br><br><span class="hljs-comment"># Dockerfile</span><br>FROM centos<br>MAINTAINER feng<br>VOLUME [<span class="hljs-string">&quot;/data1&quot;</span>,<span class="hljs-string">&quot;/data2&quot;</span>]<br><span class="hljs-comment"># 该容器运行时，这两个目录自动和宿主机的目录做好映射关系</span><br>docker build .<br><span class="hljs-comment"># 运行该镜像</span><br>docker run 镜像id<br><span class="hljs-comment"># 查看生成的容器信息</span><br>docker ps -a | head -<span class="hljs-number">2</span><br><span class="hljs-comment"># docker inspect 命令查看</span><br>docker inspect 容器id<br></code></pre></td></tr></table></figure>
<p>1.容器数据挂载的方式，通过dockerfile,指定VOLUME目录<br>2.通过docker run -v 参数，直接设置需要映射挂载的目录</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>指定容器运行时对外提供的端口服务</p>
<ul>
<li>帮助使用该镜像的人，快速理解该容器的一个端口业务</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">docker port 容器<br>docker run -p 宿主机端口:容器端口<br>docker run -P <span class="hljs-comment"># 作用是随机宿主机端口:容器端口</span><br></code></pre></td></tr></table></figure>

<h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><p>用于在Dockerfile中，目录的切换，更改工作目录</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl">WORKDIR /opt<br></code></pre></td></tr></table></figure>

<h3 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h3><p>用于改变环境，用于切换用户</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">USER root<br>USER feng<br></code></pre></td></tr></table></figure>

<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2023/07/22/Hyprland/">← Next hyprland</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/04/02/ArchLinux%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/">ArchLinux常用软件 Prev →</a></div></div></div></div><div class="bottom-btn"><div><a id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧</a><a id="to-index" href="#toc-div" title="文章目录">≡</a><a id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/1.png" alt="Logo"></a><h1 id="Dr"><a href="/">ffc</a></h1><div id="description"><p></p></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">docker 介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">2.</span> <span class="toc-text">容器和虚拟机的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.</span> <span class="toc-text">传统虚拟机技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF"><span class="toc-number">2.2.</span> <span class="toc-text">容器技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AF%B9%E6%AF%94KVM%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">2.3.</span> <span class="toc-text">容器对比KVM的好处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9docker"><span class="toc-number">2.4.</span> <span class="toc-text">为什么选择docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E8%83%BD%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">2.5.</span> <span class="toc-text">docker能做什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2"><span class="toc-number">3.</span> <span class="toc-text">docker安装部署</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E6%9C%80%E6%A0%B8%E5%BF%83%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">docker最核心的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%BC%95%E6%93%8E"><span class="toc-number">3.2.</span> <span class="toc-text">Docker引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Daemon"><span class="toc-number">3.3.</span> <span class="toc-text">Docker Daemon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rest%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.4.</span> <span class="toc-text">Rest接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker-Client"><span class="toc-number">3.5.</span> <span class="toc-text">Docker Client</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E5%B9%B3%E5%8F%B0%E7%BB%84%E6%88%90"><span class="toc-number">3.6.</span> <span class="toc-text">Docker平台组成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Images"><span class="toc-number">3.7.</span> <span class="toc-text">Images</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Container"><span class="toc-number">3.8.</span> <span class="toc-text">Container</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Registry"><span class="toc-number">3.9.</span> <span class="toc-text">Registry</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker%E7%9A%84%E5%AE%89%E8%A3%85"><span class="toc-number">4.</span> <span class="toc-text">Docker的安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">安装环境初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E8%A3%85docker"><span class="toc-number">4.2.</span> <span class="toc-text">安装docker</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">镜像加速器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E7%AC%AC%E4%B8%80%E4%B8%AAdocker%E5%AE%B9%E5%99%A8"><span class="toc-number">4.4.</span> <span class="toc-text">启动第一个docker容器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.</span> <span class="toc-text">docker的生命周期</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">docker镜像的原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">docker镜像定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E5%B1%82"><span class="toc-number">6.2.</span> <span class="toc-text">docker镜像为什么分层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E7%9A%84%E5%AE%B9%E5%99%A8%E5%B1%82"><span class="toc-number">6.3.</span> <span class="toc-text">可写的容器层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">6.4.</span> <span class="toc-text">Docker镜像的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker%E9%95%9C%E5%83%8F%E7%9A%84%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0"><span class="toc-number">6.5.</span> <span class="toc-text">docker镜像的实际使用学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%95%9C%E5%83%8F"><span class="toc-number">6.6.</span> <span class="toc-text">获取镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F"><span class="toc-number">6.7.</span> <span class="toc-text">查看镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F"><span class="toc-number">6.8.</span> <span class="toc-text">删除镜像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%AE%A1%E7%90%86"><span class="toc-number">6.9.</span> <span class="toc-text">镜像管理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dock%E5%AE%B9%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">dock容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DockerFile%E9%95%9C%E5%83%8F%E5%AE%9A%E5%88%B6"><span class="toc-number">8.</span> <span class="toc-text">DockerFile镜像定制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Dockerfile%E7%AE%80%E4%BB%8B"><span class="toc-number">8.1.</span> <span class="toc-text">Dockerfile简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dockerfile-%E6%8C%87%E4%BB%A4"><span class="toc-number">8.2.</span> <span class="toc-text">dockerfile 指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#COPY"><span class="toc-number">8.2.1.</span> <span class="toc-text">COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADD"><span class="toc-number">8.2.2.</span> <span class="toc-text">ADD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMD"><span class="toc-number">8.2.3.</span> <span class="toc-text">CMD</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%86%85%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">8.3.</span> <span class="toc-text">容器内运行程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ENTRYPOINT"><span class="toc-number">8.3.1.</span> <span class="toc-text">ENTRYPOINT</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARG%E5%92%8CENV%E6%8C%87%E4%BB%A4"><span class="toc-number">8.3.2.</span> <span class="toc-text">ARG和ENV指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VOLUE"><span class="toc-number">8.3.3.</span> <span class="toc-text">VOLUE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPOSE"><span class="toc-number">8.3.4.</span> <span class="toc-text">EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WORKDIR"><span class="toc-number">8.3.5.</span> <span class="toc-text">WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#USER"><span class="toc-number">8.3.6.</span> <span class="toc-text">USER</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr>主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {code.findCode();
document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>